<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hakurei Shrine</title>
  <subtitle>What a Shame.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lingsamuel.github.io/"/>
  <updated>2017-04-26T10:17:13.402Z</updated>
  <id>https://lingsamuel.github.io/</id>
  
  <author>
    <name>Kisaragi Sarasa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mami Sama Big Oppai</title>
    <link href="https://lingsamuel.github.io/2017/04/26/Mami-Sama-Big-Oppai/"/>
    <id>https://lingsamuel.github.io/2017/04/26/Mami-Sama-Big-Oppai/</id>
    <published>2017-04-26T10:15:57.000Z</published>
    <updated>2017-04-26T10:17:13.402Z</updated>
    
    <content type="html"><![CDATA[<p>测试测试~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试测试~&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Algorithm W</title>
    <link href="https://lingsamuel.github.io/2017/03/19/Algorithm-W/"/>
    <id>https://lingsamuel.github.io/2017/03/19/Algorithm-W/</id>
    <published>2017-03-19T09:07:50.000Z</published>
    <updated>2017-03-31T17:02:45.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="译-Algorithm-W-Step-By-Step"><a href="#译-Algorithm-W-Step-By-Step" class="headerlink" title="(译) Algorithm W Step By Step"></a>(译) Algorithm W Step By Step</h1><p>原作者 Martin Grabmüller</p>
<p>代码注释/其他语言转写将在未来补充（也有可能永远不补充）。</p>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>在这篇文章里，我们会用 Haskell 完整地实现用于 Hindley-Milner 多态类型推断(Hindley-Milner polymorphic type inference)的经典算法： W。</p>
<a id="more"></a>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>类型推断是一件很棘手的事情，也很难入门。因为大多数相关资料都是关于更加高深的话题的，例如 rank-N polymorphism，predicative/impredicative type systems，universal and existential types 等。我已经通过实际解决问题学到了一点东西，因此我决定写一篇关于类型推导的基础教程——实现一个最基础的类型推断算法，用于基本的类型检查（例如 ML 或者 Haskell）。</p>
<p>这里研究的类型推导算法是由 Milner 提出的 Algorithm W。[1]</p>
<p>有关此算法的变种、拓展或者更多信息，请参阅[2]。</p>
<p>本教程也受到[3]的启发。</p>
<h2 id="2-Algorithm-W"><a href="#2-Algorithm-W" class="headerlink" title="2. Algorithm W"></a>2. Algorithm W</h2><p>让我们从必须的 import 开始。为了表示环境（Environment，又名上下文 Context）以及替换（Substitution），我们需要 import Data.Map。类型变量的集合等将由 Data.Set 表示。</p>
<p>我们也需要一些 monad transformer，因此我们需要 import 关于 monad 的库。</p>
<p>Text.PrettyPrint 提供了一些让输出内容格式化并且缩进良好的方法，PrettyPrint 的代码在附录 A。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map</div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Set <span class="keyword">as</span> Set</div><div class="line"></div><div class="line"><span class="keyword">import</span> Control.Monad.Error</div><div class="line"><span class="keyword">import</span> Control.Monad.Reader</div><div class="line"><span class="keyword">import</span> Control.Monad.State</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Text.PrettyPrint <span class="keyword">as</span> PP</div></pre></td></tr></table></figure>
<h3 id="2-1-准备"><a href="#2-1-准备" class="headerlink" title="2.1 准备"></a>2.1 准备</h3><p>我们先定义一些抽象语法，包括 expressions (Exp)，types (Type) 以及 type schemes (Scheme)。</p>
<p>Scheme ∀a1, …, an.t 表示的是一系列通用量化（Universal Quantifier）的多态类型变量。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Exp</span> = <span class="type">EVar</span> <span class="type">String</span></span></div><div class="line">        | <span class="type">ELit</span> <span class="type">Lit</span></div><div class="line">        | <span class="type">EApp</span> <span class="type">Exp</span> <span class="type">Exp</span></div><div class="line">        | <span class="type">EAbs</span> <span class="type">String</span> <span class="type">Exp</span></div><div class="line">        | <span class="type">ELet</span> <span class="type">String</span> <span class="type">Exp</span> <span class="type">Exp</span></div><div class="line">        <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lit</span> = <span class="type">LInt</span> <span class="type">Integer</span></span></div><div class="line">        | <span class="type">LBool</span> <span class="type">Bool</span></div><div class="line">        <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Type</span> = <span class="type">TVar</span> <span class="type">String</span></span></div><div class="line">        | <span class="type">TInt</span></div><div class="line">        | <span class="type">TBool</span></div><div class="line">        | <span class="type">TFun</span> <span class="type">Type</span> <span class="type">Type</span></div><div class="line">        <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Scheme</span> = <span class="type">Scheme</span> [<span class="type">String</span>] <span class="type">Type</span></span></div></pre></td></tr></table></figure>
<p>为了提供可读的输出以及报错信息，我们定义了一些 pretty-printing 有关的方法（附录 A）。</p>
<p>我们需要确定类型的自由类型变量。ftv (free type variables) 方法实现了这一操作。我们会在 Types 这个类型类里实现这个方法，因为 type environments 也需要它（下文会提到）。另一个对 types, type schemes 等的有用操作是 apply 一个替换。一个替换仅仅替换自由类型变量，所以 type scheme 里的量化类型变量不受影响。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Types</span> a <span class="keyword">where</span></span></div><div class="line">    ftv    ::  a -&gt; <span class="type">Set</span>.<span class="type">Set</span> <span class="type">String</span></div><div class="line">    apply  ::  <span class="type">Subst</span> -&gt; a -&gt; a</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Types</span> <span class="type">Type</span> <span class="keyword">where</span></div><div class="line">    ftv (<span class="type">TVar</span> n)      =  <span class="type">Set</span>.singleton n</div><div class="line">    ftv <span class="type">TInt</span>          =  <span class="type">Set</span>.empty</div><div class="line">    ftv <span class="type">TBool</span>         =  <span class="type">Set</span>.empty</div><div class="line">    ftv (<span class="type">TFun</span> t1 t2)  =  ftv t1 `<span class="type">Set</span>.union` ftv t2</div><div class="line">    apply s (<span class="type">TVar</span> n)      =  <span class="keyword">case</span> <span class="type">Map</span>.lookup n s <span class="keyword">of</span></div><div class="line">                               <span class="type">Nothing</span>  -&gt; <span class="type">TVar</span> n</div><div class="line">                               <span class="type">Just</span> t   -&gt; t</div><div class="line">    apply s (<span class="type">TFun</span> t1 t2)  = <span class="type">TFun</span> (apply s t1) (apply s t2)</div><div class="line">    apply s t             =  t</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Types</span> <span class="type">Scheme</span> <span class="keyword">where</span></div><div class="line">    ftv (<span class="type">Scheme</span> vars t)      =  (ftv t) `<span class="type">Set</span>.difference` (<span class="type">Set</span>.fromList vars)</div><div class="line">    apply s (<span class="type">Scheme</span> vars t)  =  <span class="type">Scheme</span> vars (apply (foldr <span class="type">Map</span>.delete s vars) t)</div></pre></td></tr></table></figure>
<p>如果把 types 方法扩展到列表有时是有用的。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Types</span> a =&gt; <span class="type">Types</span> [a] <span class="keyword">where</span></span></div><div class="line">    apply s  =  map (apply s)</div><div class="line">    ftv l    =  foldr <span class="type">Set</span>.union <span class="type">Set</span>.empty (map ftv l)</div></pre></td></tr></table></figure>
<p>现在我们定义替换，它被定义为一个有限长的类型变量到类型的映射。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">Subst</span> = <span class="type">Map</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Type</span></span></div><div class="line"><span class="title">nullSubst</span>  ::  <span class="type">Subst</span></div><div class="line"><span class="title">nullSubst</span>  =   <span class="type">Map</span>.empty</div><div class="line"><span class="title">composeSubst</span>         :: <span class="type">Subst</span> -&gt; <span class="type">Subst</span> -&gt; <span class="type">Subst</span></div><div class="line"><span class="title">composeSubst</span> s1 s2   = (<span class="type">Map</span>.map (apply s1) s2) `<span class="type">Map</span>.union` s1</div></pre></td></tr></table></figure>
<p>Type environments，也就是 Γ，是一个从 term variables 到相应 type schemes 的映射。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">TypeEnv</span> = <span class="type">TypeEnv</span> (<span class="type">Map</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Scheme</span>)</span></div></pre></td></tr></table></figure>
<p>我们定义一些有关 type environments 的方法。被称为 remove 的操作 Γ\x 移除 Γ 中有关 x 的绑定。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">remove</span>                    ::  <span class="type">TypeEnv</span> -&gt; <span class="type">String</span> -&gt; <span class="type">TypeEnv</span></div><div class="line"><span class="title">remove</span> (<span class="type">TypeEnv</span> env) var  =  <span class="type">TypeEnv</span> (<span class="type">Map</span>.delete var env)</div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Types</span> <span class="type">TypeEnv</span> <span class="keyword">where</span></span></div><div class="line">    ftv (<span class="type">TypeEnv</span> env)      =  ftv (<span class="type">Map</span>.elems env)</div><div class="line">    apply s (<span class="type">TypeEnv</span> env)  =  <span class="type">TypeEnv</span> (<span class="type">Map</span>.map (apply s) env)</div></pre></td></tr></table></figure>
<p>The function |generalize| abstracts a type over all type variables<br>which are free in the type but not free in the given type environment.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">generalize</span>        ::  <span class="type">TypeEnv</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">Scheme</span></div><div class="line"><span class="title">generalize</span> env t  =   <span class="type">Scheme</span> vars t</div><div class="line">  <span class="keyword">where</span> vars = <span class="type">Set</span>.toList ((ftv t) `<span class="type">Set</span>.difference` (ftv env))</div></pre></td></tr></table></figure>
<p>Type scheme 实例化之类的操作，需要给新引入的类型变量一些新名称。通过合适的生成新名称的 monad 来实现这一想法。它同时还能传递 dynamically scoped environment，处理错误以及执行 I/O 操作。但这里暂时不介绍细节。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">TIEnv</span> = <span class="type">TIEnv</span>  &#123;&#125;</span></div><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">TIState</span> = <span class="type">TIState</span> &#123; <span class="title">tiSupply</span> :: <span class="type">Int</span> &#125;</span></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="type">TI</span> a = <span class="type">ErrorT</span> <span class="type">String</span> (<span class="type">ReaderT</span> <span class="type">TIEnv</span> (<span class="type">StateT</span> <span class="type">TIState</span> <span class="type">IO</span>)) a</span></div><div class="line"><span class="title">runTI</span> :: <span class="type">TI</span> a -&gt; <span class="type">IO</span> (<span class="type">Either</span> <span class="type">String</span> a, <span class="type">TIState</span>)</div><div class="line"><span class="title">runTI</span> t = </div><div class="line">    <span class="keyword">do</span> (res, st) &lt;- runStateT (runReaderT (runErrorT t) initTIEnv) initTIState</div><div class="line">       return (res, st)</div><div class="line">  <span class="keyword">where</span> initTIEnv = <span class="type">TIEnv</span></div><div class="line">        initTIState = <span class="type">TIState</span>&#123;tiSupply = <span class="number">0</span>&#125;</div><div class="line"><span class="title">newTyVar</span> :: <span class="type">String</span> -&gt; <span class="type">TI</span> <span class="type">Type</span></div><div class="line"><span class="title">newTyVar</span> prefix =</div><div class="line">    <span class="keyword">do</span>  s &lt;- get</div><div class="line">        put s&#123;tiSupply = tiSupply s + <span class="number">1</span>&#125;</div><div class="line">        return (<span class="type">TVar</span>  (prefix ++ show (tiSupply s)))</div></pre></td></tr></table></figure>
<p>Instantiate 方法替换一个 type scheme 里所有的绑定类型变量为新的类型变量。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">instantiate</span> :: <span class="type">Scheme</span> -&gt; <span class="type">TI</span> <span class="type">Type</span></div><div class="line"><span class="title">instantiate</span> (<span class="type">Scheme</span> vars t) = <span class="keyword">do</span>  nvars &lt;- mapM (\ _ -&gt; newTyVar <span class="string">"a"</span>) vars</div><div class="line">                                  <span class="keyword">let</span> s = <span class="type">Map</span>.fromList (zip vars nvars)</div><div class="line">                                  return $ apply s t</div></pre></td></tr></table></figure>
<p>下面的是类型的 unification 方法。对于 t1 t2 两个类型，这个方法给出最通用（general）的合一（unifier）。<br>合一是一个替换S，它使得 S(t1) ≡ S(t2)。 方法 varBind 将一个类型变量绑定为一个类型，并且返回这个绑定的替换，并且不会将一个变量绑定到自身。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="title">mgu</span> :: <span class="type">Type</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">TI</span> <span class="type">Subst</span></div><div class="line"><span class="title">mgu</span> (<span class="type">TFun</span> l r) (<span class="type">TFun</span> l' r')  =  <span class="keyword">do</span>  s1 &lt;- mgu l l'</div><div class="line">                                    s2 &lt;- mgu (apply s1 r) (apply s1 r')</div><div class="line">                                    return (s1 `composeSubst` s2)</div><div class="line"><span class="title">mgu</span> (<span class="type">TVar</span> u) t               =  varBind u t</div><div class="line"><span class="title">mgu</span> t (<span class="type">TVar</span> u)               =  varBind u t</div><div class="line"><span class="title">mgu</span> <span class="type">TInt</span> <span class="type">TInt</span>                =  return nullSubst</div><div class="line"><span class="title">mgu</span> <span class="type">TBool</span> <span class="type">TBool</span>              =  return nullSubst</div><div class="line"><span class="title">mgu</span> t1 t2                    =  throwError $ <span class="string">"types do not unify: "</span> ++ show t1 ++ </div><div class="line">                                <span class="string">" vs. "</span> ++ show t2</div><div class="line"><span class="title">varBind</span> :: <span class="type">String</span> -&gt; <span class="type">Type</span> -&gt; <span class="type">TI</span> <span class="type">Subst</span></div><div class="line"><span class="title">varBind</span> u t  | t == <span class="type">TVar</span> u           =  return nullSubst</div><div class="line">             | u `<span class="type">Set</span>.member` ftv t  =  throwError $ <span class="string">"occurs check fails: "</span> ++ u ++</div><div class="line">                                         <span class="string">" vs. "</span> ++ show t</div><div class="line">             | otherwise             =  return (<span class="type">Map</span>.singleton u t)</div></pre></td></tr></table></figure>
<h3 id="2-2-类型推断"><a href="#2-2-类型推断" class="headerlink" title="2.2 类型推断"></a>2.2 类型推断</h3><p>方法 tiLit 用于推断字面量。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">tiLit</span> :: <span class="type">Lit</span> -&gt; <span class="type">TI</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</div><div class="line"><span class="title">tiLit</span> (<span class="type">LInt</span> _)   =  return (nullSubst, <span class="type">TInt</span>)</div><div class="line"><span class="title">tiLit</span> (<span class="type">LBool</span> _)  =  return (nullSubst, <span class="type">TBool</span>)</div></pre></td></tr></table></figure>
<p>方法 ti 用于推断表达式的类型。 Type environment 必须包含表达式里所有自由变量的绑定。返回值里记录了表达式里的类型约束的替换以及表达式的类型。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="title">ti</span>        ::  <span class="type">TypeEnv</span> -&gt; <span class="type">Exp</span> -&gt; <span class="type">TI</span> (<span class="type">Subst</span>, <span class="type">Type</span>)</div><div class="line"><span class="title">ti</span> (<span class="type">TypeEnv</span> env) (<span class="type">EVar</span> n) = </div><div class="line">    <span class="keyword">case</span> <span class="type">Map</span>.lookup n env <span class="keyword">of</span></div><div class="line">       <span class="type">Nothing</span>     -&gt;  throwError $ <span class="string">"unbound variable: "</span> ++ n</div><div class="line">       <span class="type">Just</span> sigma  -&gt;  <span class="keyword">do</span>  t &lt;- instantiate sigma</div><div class="line">                           return (nullSubst, t)</div><div class="line"><span class="title">ti</span> _ (<span class="type">ELit</span> l) = tiLit l</div><div class="line"><span class="title">ti</span> env (<span class="type">EAbs</span> n e) =</div><div class="line">    <span class="keyword">do</span>  tv &lt;- newTyVar <span class="string">"a"</span></div><div class="line">        <span class="keyword">let</span> <span class="type">TypeEnv</span> env' = remove env n</div><div class="line">            env'' = <span class="type">TypeEnv</span> (env' `<span class="type">Map</span>.union` (<span class="type">Map</span>.singleton n (<span class="type">Scheme</span> [] tv)))</div><div class="line">        (s1, t1) &lt;- ti env'' e</div><div class="line">        return (s1, <span class="type">TFun</span> (apply s1 tv) t1)</div><div class="line"><span class="title">ti</span> env exp@(<span class="type">EApp</span> e1 e2) =</div><div class="line">    <span class="keyword">do</span>  tv &lt;- newTyVar <span class="string">"a"</span></div><div class="line">        (s1, t1) &lt;- ti env e1</div><div class="line">        (s2, t2) &lt;- ti (apply s1 env) e2</div><div class="line">        s3 &lt;- mgu (apply s2 t1) (<span class="type">TFun</span> t2 tv)</div><div class="line">        return (s3 `composeSubst` s2 `composeSubst` s1, apply s3 tv)</div><div class="line">    `catchError`</div><div class="line">    \e -&gt; throwError $ e ++ <span class="string">"\n in "</span> ++ show exp</div><div class="line"><span class="title">ti</span> env (<span class="type">ELet</span> x e1 e2) =</div><div class="line">    <span class="keyword">do</span>  (s1, t1) &lt;- ti env e1</div><div class="line">        <span class="keyword">let</span> <span class="type">TypeEnv</span> env' = remove env x</div><div class="line">            t' = generalize (apply s1 env) t1</div><div class="line">            env'' = <span class="type">TypeEnv</span> (<span class="type">Map</span>.insert x t' env')</div><div class="line">        (s2, t2) &lt;- ti (apply s1 env'') e2</div><div class="line">        return (s1 `composeSubst` s2, t2)</div></pre></td></tr></table></figure>
<p>这是类型推断器的入口，只是简单地调用了 ti 并且将返回的替换应用到返回的类型上。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">typeInference</span> :: <span class="type">Map</span>.<span class="type">Map</span> <span class="type">String</span> <span class="type">Scheme</span> -&gt; <span class="type">Exp</span> -&gt; <span class="type">TI</span> <span class="type">Type</span></div><div class="line"><span class="title">typeInference</span> env e =</div><div class="line">    <span class="keyword">do</span>  (s, t) &lt;- ti (<span class="type">TypeEnv</span> env) e</div><div class="line">        return (apply s t)</div></pre></td></tr></table></figure>
<h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><p>下面列出一些简单的表达式（部分取自[2]）用于测试这些方法。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="title">e0</span>  =  <span class="type">ELet</span> <span class="string">"id"</span> (<span class="type">EAbs</span> <span class="string">"x"</span> (<span class="type">EVar</span> <span class="string">"x"</span>))</div><div class="line">        (<span class="type">EVar</span> <span class="string">"id"</span>)</div><div class="line"><span class="title">e1</span>  =  <span class="type">ELet</span> <span class="string">"id"</span> (<span class="type">EAbs</span> <span class="string">"x"</span> (<span class="type">EVar</span> <span class="string">"x"</span>))</div><div class="line">        (<span class="type">EApp</span> (<span class="type">EVar</span> <span class="string">"id"</span>) (<span class="type">EVar</span> <span class="string">"id"</span>))</div><div class="line"><span class="title">e2</span>  =  <span class="type">ELet</span> <span class="string">"id"</span> (<span class="type">EAbs</span> <span class="string">"x"</span> (<span class="type">ELet</span> <span class="string">"y"</span> (<span class="type">EVar</span> <span class="string">"x"</span>) (<span class="type">EVar</span> <span class="string">"y"</span>)))</div><div class="line">        (<span class="type">EApp</span> (<span class="type">EVar</span> <span class="string">"id"</span>) (<span class="type">EVar</span> <span class="string">"id"</span>))</div><div class="line"><span class="title">e3</span>  =  <span class="type">ELet</span> <span class="string">"id"</span> (<span class="type">EAbs</span> <span class="string">"x"</span> (<span class="type">ELet</span> <span class="string">"y"</span> (<span class="type">EVar</span> <span class="string">"x"</span>) (<span class="type">EVar</span> <span class="string">"y"</span>)))</div><div class="line">        (<span class="type">EApp</span> (<span class="type">EApp</span> (<span class="type">EVar</span> <span class="string">"id"</span>) (<span class="type">EVar</span> <span class="string">"id"</span>)) (<span class="type">ELit</span> (<span class="type">LInt</span> <span class="number">2</span>)))</div><div class="line"><span class="title">e4</span>  =  <span class="type">ELet</span> <span class="string">"id"</span> (<span class="type">EAbs</span> <span class="string">"x"</span> (<span class="type">EApp</span> (<span class="type">EVar</span> <span class="string">"x"</span>) (<span class="type">EVar</span> <span class="string">"x"</span>)))</div><div class="line">        (<span class="type">EVar</span> <span class="string">"id"</span>)</div><div class="line"><span class="title">e5</span>  =  <span class="type">EAbs</span> <span class="string">"m"</span> (<span class="type">ELet</span> <span class="string">"y"</span> (<span class="type">EVar</span> <span class="string">"m"</span>)</div><div class="line">                 (<span class="type">ELet</span> <span class="string">"x"</span> (<span class="type">EApp</span> (<span class="type">EVar</span> <span class="string">"y"</span>) (<span class="type">ELit</span> (<span class="type">LBool</span> <span class="type">True</span>)))</div><div class="line">                       (<span class="type">EVar</span> <span class="string">"x"</span>)))</div><div class="line">       </div><div class="line"><span class="title">e6</span>  =  <span class="type">EApp</span> (<span class="type">ELit</span> (<span class="type">LInt</span> <span class="number">2</span>)) (<span class="type">ELit</span> (<span class="type">LInt</span> <span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>下面这个简单的测试函数试图推断给定表达式的类型。如果成功了，它将打印出这个表达式和它的类型，否则，打印错误信息。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">test</span> :: <span class="type">Exp</span> -&gt; <span class="type">IO</span> ()</div><div class="line"><span class="title">test</span> e =</div><div class="line">    <span class="keyword">do</span>  (res, _) &lt;- runTI (typeInference <span class="type">Map</span>.empty e)</div><div class="line">        <span class="keyword">case</span> res <span class="keyword">of</span></div><div class="line">          <span class="type">Left</span> err  -&gt;  putStrLn $ show e ++ <span class="string">"\n "</span> ++ err ++ <span class="string">"\n"</span></div><div class="line">          <span class="type">Right</span> t   -&gt;  putStrLn $ show e ++ <span class="string">" :: "</span> ++ show t ++ <span class="string">"\n"</span></div></pre></td></tr></table></figure>
<h3 id="2-4-Main"><a href="#2-4-Main" class="headerlink" title="2.4 Main"></a>2.4 Main</h3><p>Main 只是简单地推断了所有示例表达式并且将它们和所推导出来的类型一同打印出来，如果失败，将打印错误信息。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</div><div class="line"><span class="title">main</span> = mapM_ test [e0, e1, e2, e3, e4, e5, e6]</div><div class="line"><span class="comment">-- |Collecting Constraints|</span></div><div class="line"><span class="comment">-- |main = mapM_ test' [e0, e1, e2, e3, e4, e5]|</span></div></pre></td></tr></table></figure>
<p>这就是这个类型推导算法的全部实现了。</p>
<h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h2><p>这些 Haskell 代码是一个自包含的 Algorithm W 实现。你可以随意使用、扩展这些代码，让它能够支持更好的错误信息、类型类、类型注解等等。最终你也许会得到一个完整地 Haskell 的类型检查器。</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p>[1] Copied from <a href="http://www.grabmueller.de/martin/www/pub/AlgorithmW.en.html" target="_blank" rel="external">http://www.grabmueller.de/martin/www/pub/AlgorithmW.en.html</a> and edited by Wei Hu. Unfortunately the bibliography is missing. </p>
<p>[2] The most helpful references are <a href="http://www.cs.uu.nl/research/techreps/repo/CS-2002/2002-031.pdf" target="_blank" rel="external">http://www.cs.uu.nl/research/techreps/repo/CS-2002/2002-031.pdf</a> Generalizing Hindley-Milner Type Inference Algorithms, and Chapter 22 of TAPL.</p>
<p>[3] A Cornell course touchs on this topic and gives an OCaml implementation. <a href="http://www.cs.cornell.edu/Courses/cs3110/2009fa/lectures/lec26a.htm" target="_blank" rel="external">http://www.cs.cornell.edu/Courses/cs3110/2009fa/lectures/lec26a.htm</a></p>
<h2 id="附录-A"><a href="#附录-A" class="headerlink" title="附录 A"></a>附录 A</h2><p>本附录提供了 pretty-printing 方法和 type 的 Show 类型类实例。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Type</span> <span class="keyword">where</span></span></div><div class="line">    showsPrec _ x = shows (prType x)</div><div class="line"><span class="title">prType</span>             ::  <span class="type">Type</span> -&gt; <span class="type">PP</span>.<span class="type">Doc</span></div><div class="line"><span class="title">prType</span> (<span class="type">TVar</span> n)    =   <span class="type">PP</span>.text n</div><div class="line"><span class="title">prType</span> <span class="type">TInt</span>        =   <span class="type">PP</span>.text <span class="string">"Int"</span></div><div class="line"><span class="title">prType</span> <span class="type">TBool</span>       =   <span class="type">PP</span>.text <span class="string">"Bool"</span></div><div class="line"><span class="title">prType</span> (<span class="type">TFun</span> t s)  =   prParenType t <span class="type">PP</span>.&lt;+&gt; <span class="type">PP</span>.text <span class="string">"-&gt;"</span> <span class="type">PP</span>.&lt;+&gt; prType s</div><div class="line"><span class="title">prParenType</span>     ::  <span class="type">Type</span> -&gt; <span class="type">PP</span>.<span class="type">Doc</span></div><div class="line"><span class="title">prParenType</span>  t  =   <span class="keyword">case</span> t <span class="keyword">of</span></div><div class="line">                      <span class="type">TFun</span> _ _  -&gt; <span class="type">PP</span>.parens (prType t)</div><div class="line">                      _         -&gt; prType t</div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Exp</span> <span class="keyword">where</span></span></div><div class="line">    showsPrec _ x = shows (prExp x)</div><div class="line"><span class="title">prExp</span>                  ::  <span class="type">Exp</span> -&gt; <span class="type">PP</span>.<span class="type">Doc</span></div><div class="line"><span class="title">prExp</span> (<span class="type">EVar</span> name)      =   <span class="type">PP</span>.text name</div><div class="line"><span class="title">prExp</span> (<span class="type">ELit</span> lit)       =   prLit lit</div><div class="line"><span class="title">prExp</span> (<span class="type">ELet</span> x b body)  =   <span class="type">PP</span>.text <span class="string">"let"</span> <span class="type">PP</span>.&lt;+&gt; </div><div class="line">                           <span class="type">PP</span>.text x <span class="type">PP</span>.&lt;+&gt; <span class="type">PP</span>.text <span class="string">"="</span> <span class="type">PP</span>.&lt;+&gt;</div><div class="line">                           prExp b <span class="type">PP</span>.&lt;+&gt; <span class="type">PP</span>.text <span class="string">"in"</span> <span class="type">PP</span>.$$</div><div class="line">                           <span class="type">PP</span>.nest <span class="number">2</span> (prExp body)</div><div class="line"><span class="title">prExp</span> (<span class="type">EApp</span> e1 e2)     =   prExp e1 <span class="type">PP</span>.&lt;+&gt; prParenExp e2</div><div class="line"><span class="title">prExp</span> (<span class="type">EAbs</span> n e)       =   <span class="type">PP</span>.char '\\' <span class="type">PP</span>.&lt;&gt; <span class="type">PP</span>.text n <span class="type">PP</span>.&lt;+&gt;</div><div class="line">                           <span class="type">PP</span>.text <span class="string">"-&gt;"</span> <span class="type">PP</span>.&lt;+&gt;</div><div class="line">                           prExp e</div><div class="line">                                                                   </div><div class="line"><span class="title">prParenExp</span>    ::  <span class="type">Exp</span> -&gt; <span class="type">PP</span>.<span class="type">Doc</span></div><div class="line"><span class="title">prParenExp</span> t  =   <span class="keyword">case</span> t <span class="keyword">of</span></div><div class="line">                    <span class="type">ELet</span> _ _ _  -&gt; <span class="type">PP</span>.parens (prExp t)</div><div class="line">                    <span class="type">EApp</span> _ _    -&gt; <span class="type">PP</span>.parens (prExp t)</div><div class="line">                    <span class="type">EAbs</span> _ _    -&gt; <span class="type">PP</span>.parens (prExp t)</div><div class="line">                    _           -&gt; prExp t</div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Lit</span> <span class="keyword">where</span></span></div><div class="line">    showsPrec _ x = shows (prLit x)</div><div class="line"><span class="title">prLit</span>            ::  <span class="type">Lit</span> -&gt; <span class="type">PP</span>.<span class="type">Doc</span></div><div class="line"><span class="title">prLit</span> (<span class="type">LInt</span> i)   =   <span class="type">PP</span>.integer i</div><div class="line"><span class="title">prLit</span> (<span class="type">LBool</span> b)  =   <span class="keyword">if</span> b <span class="keyword">then</span> <span class="type">PP</span>.text <span class="string">"True"</span> <span class="keyword">else</span> <span class="type">PP</span>.text <span class="string">"False"</span></div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Scheme</span> <span class="keyword">where</span></span></div><div class="line">    showsPrec _ x = shows (prScheme x)</div><div class="line"><span class="title">prScheme</span>                  ::  <span class="type">Scheme</span> -&gt; <span class="type">PP</span>.<span class="type">Doc</span></div><div class="line"><span class="title">prScheme</span> (<span class="type">Scheme</span> vars t)  =   <span class="type">PP</span>.text <span class="string">"All"</span> <span class="type">PP</span>.&lt;+&gt;</div><div class="line">                              <span class="type">PP</span>.hcat </div><div class="line">                                (<span class="type">PP</span>.punctuate <span class="type">PP</span>.comma (map <span class="type">PP</span>.text vars))</div><div class="line">                              <span class="type">PP</span>.&lt;&gt; <span class="type">PP</span>.text <span class="string">"."</span> <span class="type">PP</span>.&lt;+&gt; prType t</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;译-Algorithm-W-Step-By-Step&quot;&gt;&lt;a href=&quot;#译-Algorithm-W-Step-By-Step&quot; class=&quot;headerlink&quot; title=&quot;(译) Algorithm W Step By Step&quot;&gt;&lt;/a&gt;(译) Algorithm W Step By Step&lt;/h1&gt;&lt;p&gt;原作者 Martin Grabmüller&lt;/p&gt;
&lt;p&gt;代码注释/其他语言转写将在未来补充（也有可能永远不补充）。&lt;/p&gt;
&lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;p&gt;在这篇文章里，我们会用 Haskell 完整地实现用于 Hindley-Milner 多态类型推断(Hindley-Milner polymorphic type inference)的经典算法： W。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Type System" scheme="https://lingsamuel.github.io/tags/Type-System/"/>
    
  </entry>
  
  <entry>
    <title>Shikaiia-Design</title>
    <link href="https://lingsamuel.github.io/2017/03/16/Shikaiia-Design/"/>
    <id>https://lingsamuel.github.io/2017/03/16/Shikaiia-Design/</id>
    <published>2017-03-16T14:56:52.000Z</published>
    <updated>2017-03-17T20:57:48.734Z</updated>
    
    <content type="html"><![CDATA[<p>The game I want to play.</p>
<a id="more"></a>
<p>我一直有几个想法萦绕在脑海里，但是我没法优雅地将它们结合在一起。</p>
<p>不过最近我想通了，它们已经被分成几个不同的项目——也可能是一个项目的几种模式，总之，它们不会再被试图糅合在一起了。</p>
<h1 id="龙与地下城"><a href="#龙与地下城" class="headerlink" title="龙与地下城"></a>龙与地下城</h1><p>这个故事的主角是 Bounty Hunter，或者说，Dungeon Master。</p>
<h2 id="小规模的战棋与卡牌收集"><a href="#小规模的战棋与卡牌收集" class="headerlink" title="小规模的战棋与卡牌收集"></a>小规模的战棋与卡牌收集</h2><h1 id="政治斗争与历史的浪潮"><a href="#政治斗争与历史的浪潮" class="headerlink" title="政治斗争与历史的浪潮"></a>政治斗争与历史的浪潮</h1><p>这个故事发生在 Shikaiia - 希卡艾亚。</p>
<h2 id="大规模的战争模拟"><a href="#大规模的战争模拟" class="headerlink" title="大规模的战争模拟"></a>大规模的战争模拟</h2><p>与希卡艾亚的故事背景所符合，它衍生的游戏类型是大规模的战棋——当然，不仅仅局限于现有势力。</p>
<h1 id="英雄史诗、龙与其他种族"><a href="#英雄史诗、龙与其他种族" class="headerlink" title="英雄史诗、龙与其他种族"></a>英雄史诗、龙与其他种族</h1><p>这个故事发生在 Drowvillen - 卓尔维仑。</p>
<h2 id="高魔世界的传统沙盒"><a href="#高魔世界的传统沙盒" class="headerlink" title="高魔世界的传统沙盒"></a>高魔世界的传统沙盒</h2><h1 id="小人物的故事与奇幻世界"><a href="#小人物的故事与奇幻世界" class="headerlink" title="小人物的故事与奇幻世界"></a>小人物的故事与奇幻世界</h1><p>这个故事发生在 Advanvince - 艾德凡温斯。</p>
<h2 id="Roguelike-的硬核-RPG"><a href="#Roguelike-的硬核-RPG" class="headerlink" title="Roguelike 的硬核 RPG"></a>Roguelike 的硬核 RPG</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The game I want to play.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game" scheme="https://lingsamuel.github.io/tags/Game/"/>
    
      <category term="Fun" scheme="https://lingsamuel.github.io/tags/Fun/"/>
    
  </entry>
  
  <entry>
    <title>Fancy and Trivial</title>
    <link href="https://lingsamuel.github.io/2017/03/09/Fancy-and-Trivial/"/>
    <id>https://lingsamuel.github.io/2017/03/09/Fancy-and-Trivial/</id>
    <published>2017-03-09T15:59:25.000Z</published>
    <updated>2017-03-09T16:05:33.551Z</updated>
    
    <content type="html"><![CDATA[<p>一种假象。</p>
<a id="more"></a>
<p>编程的初学者往往都会陷入一个陷阱，就是迷信“做中学”。</p>
<p>我并不是说做中学不对，只是真正的做中学怕不是网上的什么教程能教会的。</p>
<p>网上的教程，往往用一些很 fancy 的例子吸引新手入门，但其实这些东西都很 trivial。</p>
<p>我可能算是走过许多弯路的了。</p>
<p>如果有人曾经看到过我的 GitHub/GitLab，会发现曾经我在上面都是一片绿/蓝，但现在我都把这些 repo 删掉了。</p>
<p>因为做的东西实在没有什么技术含量，都是很 trivial 的。比如什么知乎日报 Android 端、BBS、仿制的知乎。</p>
<p>而新手正容易被这些东西吸引。</p>
<p>现在你问我怎么入门，我可能会掏出一大叠书送给你。</p>
<p>真正有用的东西，最后还是绕不开这些经典的教材。</p>
<p>会<strong>简单使用</strong>用一些框架，其实是个民工都能做。</p>
<p>要么扎扎实实从头开始，要么就<strong>深入</strong>进去。</p>
<p>然而深入的前提是扎扎实实。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一种假象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://lingsamuel.github.io/tags/Life/"/>
    
      <category term="Misc" scheme="https://lingsamuel.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Books</title>
    <link href="https://lingsamuel.github.io/2017/01/15/Books/"/>
    <id>https://lingsamuel.github.io/2017/01/15/Books/</id>
    <published>2017-01-14T19:47:33.000Z</published>
    <updated>2017-01-14T19:52:09.183Z</updated>
    
    <content type="html"><![CDATA[<hr>
<ol>
<li>SICP</li>
<li>CSAPP</li>
<li>Learn You a Haskell in Great Good</li>
<li>Types and Programming Languages</li>
<li>Kotlin Specification</li>
</ol>
<hr>
<ol>
<li>Introduction to Lambda Calculus</li>
<li>Introduction to Algorithm</li>
</ol>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;SICP&lt;/li&gt;
&lt;li&gt;CSAPP&lt;/li&gt;
&lt;li&gt;Learn You a Haskell in Great Good&lt;/li&gt;
&lt;li&gt;Types and Programming Languages&lt;/li&gt;
&lt;li&gt;Kotlin Specif
    
    </summary>
    
    
      <category term="Plan" scheme="https://lingsamuel.github.io/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>Make a Lisp Step 0</title>
    <link href="https://lingsamuel.github.io/2017/01/14/Make-a-Lisp-Step-0/"/>
    <id>https://lingsamuel.github.io/2017/01/14/Make-a-Lisp-Step-0/</id>
    <published>2017-01-14T09:20:36.000Z</published>
    <updated>2017-01-14T19:35:59.828Z</updated>
    
    <content type="html"><![CDATA[<p>Make A Lisp!</p>
<a id="more"></a>
<h1 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h1><p>我们先定义几个类型，基类是 <code>Type</code>，里面的东西可以随意填充，现在只是用作参数类型，还没有什么用。<br><code>TrueType</code> 和 <code>FalseType</code> 单独拿来作一个类型纯属个人喜好（怀念 Haskell），你也可以把他作为一个常量。<br>前 7 个类型与后面的正则一一对应。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">IntegerType</div><div class="line">NilType</div><div class="line">TrueType</div><div class="line">FalseType</div><div class="line">StringType</div><div class="line">KeywordType</div><div class="line">SymbolType</div><div class="line"></div><div class="line">ListType</div></pre></td></tr></table></figure></p>
<h1 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h1><p>定义几个方法。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span>: String?</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(code: <span class="type">String</span>?)</span></span>: Type</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(s: <span class="type">Type</span>)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rep</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p>
<p>其中，<code>rep</code> 用来调用其他三个方法。</p>
<h1 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h1><p>Mal 提供了两个正则表达式来作 tokenize。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> TOKEN_REGEX = Regex(<span class="string">"""[\s,]*(~@|[\[\]&#123;&#125;()'`~^@]|"(?:\\.|[^\\"])*"|;.*|[^\s\[\]&#123;&#125;('"`,;)]*)"""</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> PRIM_REGEX = Regex(<span class="string">"""(^-?[0-9]+$)|(^nil$)|(^true$)|(^false$)|^"(.*)"$|:(.*)|(^[^"]*$)"""</span>)</div></pre></td></tr></table></figure></p>
<p>我们把得到的 Token 放进一个 <code>TokenReader</code> 类，比如说它实际上是一个链表之类的数据结构，（至少）能够获取当前 Token 和下一个 Token。</p>
<p>加入几个方法，因为是 step 1，所以只支持 <code>form</code>, <code>list</code>, <code>primitive</code> 就行了。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readForm</span><span class="params">(reader: <span class="type">Reader</span>)</span></span>: Type</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readList</span><span class="params">(reader: <span class="type">Reader</span>)</span></span>: Type</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readPrimitive</span><span class="params">(reader: <span class="type">Reader</span>)</span></span>: Type</div></pre></td></tr></table></figure></p>
<h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2><p><code>Form</code> 的形式（目前）很简单，只要看看当前的 token 是不是 <code>null</code>, <code>(</code>, <code>)</code> 就行了。<br>如果是 <code>null</code>，那么就结束，如果是 <code>)</code>，就抛出一个异常（因为闭括号在 <code>readList</code> 里处理了），如果是开括号，就调用 <code>readList</code>，其他情形我们直接调用 <code>readPrimitive</code>。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><code>List</code> 的形式和 <code>Form</code> 类似，我们一直读入下一个 token，如果它是 <code>null</code>，那么抛出一个异常就好了，如果是 <code>)</code>，那么这个 list 就算读取完毕了，其他情形我们直接调用 <code>readForm</code>。对于每一个结束（遇到 <code>)</code>）前的 <code>Type</code>，我们就把它加入到 <code>ListType</code> 的某种数据结构中（例如链表），作为这个 Type 的值。</p>
<h2 id="PrimitiveType"><a href="#PrimitiveType" class="headerlink" title="PrimitiveType"></a>PrimitiveType</h2><p>我们只需要对 token 应用一下上面提到的那个正则表达式即可。这个正则表达式的结果是分组的，我们可以依次判断这些组的值是不是 <code>null</code>（而且应当只有一个不是 <code>null</code>）。不是 <code>null</code> 的情形即为这个 token 的基本类型。</p>
<h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>现在我们有一个能够正确解析很多东西的小玩具了——虽然它连算数都不会。<br>如果你的实现很好的话，它已经能正确处理换行了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Make A Lisp!&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lingsamuel.github.io/tags/Kotlin/"/>
    
      <category term="Lisp" scheme="https://lingsamuel.github.io/tags/Lisp/"/>
    
  </entry>
  
  <entry>
    <title>也许你们不知道，但 Kotlin 也像 Lisp</title>
    <link href="https://lingsamuel.github.io/2017/01/10/%E4%B9%9F%E8%AE%B8%E4%BD%A0%E4%BB%AC%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8C%E4%BD%86-Kotlin-%E4%B9%9F%E5%83%8F-Lisp/"/>
    <id>https://lingsamuel.github.io/2017/01/10/也许你们不知道，但-Kotlin-也像-Lisp/</id>
    <published>2017-01-09T17:10:07.000Z</published>
    <updated>2017-01-14T19:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>老文重发。<br><a id="more"></a></p>
<p><a href="https://blog.jetbrains.com/kotlin/2014/04/kotlin-gets-support-for-s-expressions/" target="_blank" rel="external">Kotlin Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老文重发。&lt;br&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lingsamuel.github.io/tags/Kotlin/"/>
    
      <category term="Lisp" scheme="https://lingsamuel.github.io/tags/Lisp/"/>
    
  </entry>
  
  <entry>
    <title>我推荐的学习方法</title>
    <link href="https://lingsamuel.github.io/2017/01/09/%E6%88%91%E6%8E%A8%E8%8D%90%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://lingsamuel.github.io/2017/01/09/我推荐的学习方法/</id>
    <published>2017-01-09T15:07:47.000Z</published>
    <updated>2017-01-09T15:25:53.005Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，上课的效率是极度低下的，复习考试（除了数学课），对学习什么知识也基本是没用的。</p>
<p>那么正确的学习方法是什么呢？那就是自学。</p>
<p>遇到不懂的地方怎么办呢？如果思考了很久还没有弄懂的话，建议询问他人（包括搜索引擎）。如果还是感觉半懂不懂的，我建议暂时放下，以后再回头看看，往往更可能弄懂。因为这个时候你很可能陷入了误区，或者是你的知识体系还没有牢固到准备接受这块知识。至少于我而言，大部分时候我在有更多知识后回头看这些问题，发现当时没弄懂的原因都是这样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，上课的效率是极度低下的，复习考试（除了数学课），对学习什么知识也基本是没用的。&lt;/p&gt;
&lt;p&gt;那么正确的学习方法是什么呢？那就是自学。&lt;/p&gt;
&lt;p&gt;遇到不懂的地方怎么办呢？如果思考了很久还没有弄懂的话，建议询问他人（包括搜索引擎）。如果还是感觉半懂不懂的，我建议
    
    </summary>
    
    
      <category term="Misc" scheme="https://lingsamuel.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Type System</title>
    <link href="https://lingsamuel.github.io/2017/01/04/Introduction-to-Type-System/"/>
    <id>https://lingsamuel.github.io/2017/01/04/Introduction-to-Type-System/</id>
    <published>2017-01-03T17:02:11.000Z</published>
    <updated>2017-01-03T17:10:35.957Z</updated>
    
    <content type="html"><![CDATA[<p>看完你也不会有收获的类型系统笔记</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完你也不会有收获的类型系统笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="Type System" scheme="https://lingsamuel.github.io/tags/Type-System/"/>
    
      <category term="Note" scheme="https://lingsamuel.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Projects in Winter Vacation</title>
    <link href="https://lingsamuel.github.io/2017/01/04/Projects-in-Winter-Vacation/"/>
    <id>https://lingsamuel.github.io/2017/01/04/Projects-in-Winter-Vacation/</id>
    <published>2017-01-03T16:52:43.000Z</published>
    <updated>2017-01-03T17:03:42.568Z</updated>
    
    <content type="html"><![CDATA[<p>Flags</p>
<a id="more"></a>
<p>寒假填坑季</p>
<ol>
<li>一个卡片游戏框架</li>
<li>一个用 kotlin 造的小语言，考虑 kotlin 能操作它（它操作 kotlin 似乎有点复杂？）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flags&lt;/p&gt;
    
    </summary>
    
    
      <category term="Plan" scheme="https://lingsamuel.github.io/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Tutorial Chap.0</title>
    <link href="https://lingsamuel.github.io/2017/01/04/Kotlin-Tutorial-Chap-0/"/>
    <id>https://lingsamuel.github.io/2017/01/04/Kotlin-Tutorial-Chap-0/</id>
    <published>2017-01-03T16:52:09.000Z</published>
    <updated>2017-01-03T17:03:45.661Z</updated>
    
    <content type="html"><![CDATA[<p>Getting started</p>
<a id="more"></a>
<p>据称，每一篇教程都应该有一个教你怎么配环境的章节，这个章节的阅读量是最最大的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Getting started&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lingsamuel.github.io/tags/Kotlin/"/>
    
      <category term="Tutorial" scheme="https://lingsamuel.github.io/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Tutorial Chap.2</title>
    <link href="https://lingsamuel.github.io/2016/12/23/Kotlin-Tutorial-Chap-2/"/>
    <id>https://lingsamuel.github.io/2016/12/23/Kotlin-Tutorial-Chap-2/</id>
    <published>2016-12-23T07:23:58.000Z</published>
    <updated>2017-03-09T15:58:22.435Z</updated>
    
    <content type="html"><![CDATA[<p>Something about Variance</p>
<a id="more"></a>
<p>此文错误较多，请勿继续参考。</p>
<h1 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h1><p>类型构造时，构成类型的子类型性质可以被保持、反转或忽略，称作型变性质，型变(Variance)就是指依照某种构造的型变性质，确定复合类型的子类型关系。</p>
<blockquote>
<ul>
<li>Covariance</li>
</ul>
<p>使你能够使用比原始指定的类型派生程度更大的类型。<br>你可以向 IEnumerable<derived> 类型的变量分配 IEnumerable(Of Derived)（在 Visual Basic 中为 IEnumerable<base>）的实例。</derived></p>
<ul>
<li>Contravariance</li>
</ul>
<p>使你能够使用比原始指定的类型更泛型（派生程度更小）的类型。<br>你可以向 IEnumerable<base> 类型的变量分配 IEnumerable(Of Base)（在 Visual Basic 中为 IEnumerable<derived>）的实例。</derived></p>
<ul>
<li>Invariance</li>
</ul>
<p>这意味着，你只能使用原始指定的类型；固定泛型类型参数既不是协变类型，也不是逆变类型。<br>你无法向 IEnumerable<base> 类型的变量分配 IEnumerable(Of Base)（在 Visual Basic 中为 IEnumerable<derived>）的实例，反之亦然。</derived></p>
</blockquote>
<p>上文来自<a href="https://msdn.microsoft.com/zh-cn/library/dd799517.aspx" target="_blank" rel="external">泛型中的协变和逆变</a>，简而言之就是协变可以使用更加特化的版本，逆变可以使用更加泛化的版本。</p>
<h2 id="Covariant"><a href="#Covariant" class="headerlink" title="Covariant"></a>Covariant</h2><p>称协变(Covariant)为能保持子类型关系的型变性质。</p>
<p>例如，<code>Plate&lt;Apple&gt;</code>是<code>Plate&lt;Fruit&gt;</code>的子类型（显然装苹果的盘子也是一个装了水果的盘子），也即是说，<code>Apple</code>和<code>Fruit</code>间的子类型关系（苹果也是水果）被保持了，此时<code>Plate</code>就是协变的。</p>
<p>在 Java 里，它应该是这样的，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plate&lt;? extends Fruit&gt;</div></pre></td></tr></table></figure></p>
<p>意即任意派生自<code>Fruit</code>的类型都能作类型参数，此时它是协变的。<br>在 Java 里，这个叫做<strong>上界通配符</strong>。</p>
<h2 id="Contravariant"><a href="#Contravariant" class="headerlink" title="Contravariant"></a>Contravariant</h2><p>称逆变(Contravariant)为反转子类型关系的型变性质。</p>
<p>例如，<code>Eat&lt;Apple&gt;</code>是<code>Eat&lt;Fruit&gt;</code>的超类。此处，<code>Eat&lt;T&gt;</code>的子类型关系与<code>T</code>相比，被反转了，这就是逆变。</p>
<p>在 Java 里，它是这样的，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Eat&lt;? <span class="keyword">super</span> Apple&gt;</div></pre></td></tr></table></figure></p>
<p>意味着任何<code>Apple</code>的超类都能作类型参数，它可能是<code>Fruit</code>，或者<code>Food</code>，但必须记住，和<code>Eat</code>复合后，子类型关系被<strong>反转</strong>了。<br>在 Java 里，这个叫做<strong>下界通配符</strong>。</p>
<h2 id="Invariant"><a href="#Invariant" class="headerlink" title="Invariant"></a>Invariant</h2><p>称不变(Invariant)为忽略子类型关系的型变性质。</p>
<p>例如，<code>List&lt;Apple&gt;</code>和<code>List&lt;Fruit&gt;</code>之间没有什么子类型关系，此时就称之不变。</p>
<h2 id="合理地使用"><a href="#合理地使用" class="headerlink" title="合理地使用"></a>合理地使用</h2><p>一般来说，我们应该尽量使用协变或者逆变，而不是不变。</p>
<p>考虑不变的情形，我们有一个<code>Plate&lt;Fruit&gt;</code>，但它不能放入<code>Apple</code>，这种情形会让程序员困惑。</p>
<p>但有时候我们需要不变来保持类型安全。</p>
<p>设想一个数组<code>Fruit[]</code>，存在以下三种情形，</p>
<ul>
<li>协变： <code>Apple[]</code>也是<code>Fruit[]</code></li>
<li>逆变： <code>Fruit[]</code>也是<code>Apple[]</code></li>
<li>不变： 以上情形均不符合</li>
</ul>
<p>如果它是协变的，那么在<code>Apple[]</code>被当做<code>Fruit[]</code>后，可能会往内放入<code>Banana</code>，但这个<code>Fruit[]</code>实际上是<code>Apple[]</code>，是没法放入<code>Banana</code>的，因此协变是不安全的。</p>
<p>如果它是逆变的，在<code>Fruit[]</code>被当做<code>Apple[]</code>时，可能会取出一个<code>Banana</code>，因为这个<code>Apple[]</code>实际上是任何水果都可能出现的<code>Fruit[]</code>，因此逆变是不安全的。</p>
<p>不过，协变问题只对可变类型有影响，只要一个数据类型是不可变的(immutable)，它就不存在协变问题，也就是说协变是必然安全的。同理，我们可以发现，对于一个只写类型而言，逆变也是没有关系的；对只写函数而言，逆变也是无妨的。也就是说，协变存在写入问题，逆变存在读取问题。</p>
<p>这种情况，有一个叫做 PECS 原则的通俗化描述，也就是 Producer Extends Consumer Super，即是说生产者协变，消费者逆变。生产者不接受该类型作参数只返回其，消费者不返回该参数只接受其作参数。</p>
<p>在 Java 中，我们能在声明处使用一种叫做通配符的技术获取一个协变或者逆变的类型。这样就会导致类似<code>set</code>或者<code>get</code>出现问题。</p>
<p>在 C# 中，我们有 <code>in</code> 和 <code>out</code> 关键字可以手动控制这种规则，但默认是不变的，这会强制让使用者考虑型变带来的结果，个人认为是更好的。</p>
<h3 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h3><p>对于一个<code>Fruit-&gt;Fruit</code>的函数而言，用一个<code>Apple-&gt;Fruit</code>代替是安全的，<code>Apple-&gt;Fruit</code>用<code>Apple-&gt;Apple</code>替代也是安全的。这即是说，对函数而言，参数是逆变的，返回值是协变的。</p>
<p>返回值协变是安全的，例如在 Java 中，子类的方法能返回一个更特化的类型，即使子类被转为基类，因为基类的返回值更加泛化，容纳一个特化类型是允许的。<br>但是 Java 不支持参数逆变而是视作重载，这也是合理的，但应当在默认不变的基础上允许程序员让它逆变。</p>
<p>参数协变是危险（类型不安全）的，例如，在 Java 中，一个子类的一个函数，接受一个更特化的 Apple，然后子类被转为基类，并且试图传入一个 Banana 作为参数，则会引发类型错误。</p>
<hr>
<h1 id="Kotlin-的解决方案"><a href="#Kotlin-的解决方案" class="headerlink" title="Kotlin 的解决方案"></a>Kotlin 的解决方案</h1><p>回到 Kotlin 上，Kotlin 有一些特殊的技术使得一些在 Java 中不可能的代码成为可能。</p>
<h2 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h2><p>对于只读不写的泛型接口来说，协变安全是显然的，因此在泛型参数<code>T</code>前加关键字<code>out</code>表明它是一个 out-parameter 并且强制要求它只 return(produce) T。<code>out</code>的含义是，它只出现在 out-position，也就是返回值，也就是前面提到的 produce。<br>同理，<code>in</code>关键字就是 consume 含义。</p>
<p>称<code>in</code>与<code>out</code>为型变注解，只有类和接口的类型参数能被修饰。</p>
<p>事实上 C# 早就有这个东西了。</p>
<h2 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h2><h3 id="使用处型变"><a href="#使用处型变" class="headerlink" title="使用处型变"></a>使用处型变</h3><p>我们也可以对符合规则的函数参数的类型参数进行注解，称其为使用处型变。<br>例如，<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printArr</span><span class="params">(src: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;)</span></span>&#123; </div><div class="line">	<span class="comment">//... </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它能强制保证这个函数对<code>src</code>的使用符合 out 或 in 规则。<br>注意，其他参数（如果有）可以不受限制。</p>
<h3 id="星型投影"><a href="#星型投影" class="headerlink" title="星型投影"></a>星型投影</h3><p>有时候我们对类型参数一无所知，我们便可以使用星型投影来获得一种安全的使用方式。</p>
<p>对一个<code>interface Star&lt;out T&gt;</code>，其中<code>T</code>有上界约束<code>Upper</code>（默认是<code>Any?</code>），<code>Star&lt;*&gt;</code>代表<code>Star&lt;out Upper&gt;</code>，也就是说如果你对它的类型一无所知，你依然可以对它的上界进行安全地读取。<br>对一个<code>interface Star&lt;in T&gt;</code>，<code>Star&lt;*&gt;</code>代表<code>Star&lt;in Nothing&gt;</code>，也就是说你对类型一无所知的时候，你就无法安全地写它。<br>对一个<code>interface Star&lt;T&gt;</code>，<code>Star&lt;*&gt;</code>代表的含义根据读写情况变成上面两种情形。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Something about Variance&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lingsamuel.github.io/tags/Kotlin/"/>
    
      <category term="Tutorial" scheme="https://lingsamuel.github.io/tags/Tutorial/"/>
    
      <category term="Variance" scheme="https://lingsamuel.github.io/tags/Variance/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Tutorial Chap.1</title>
    <link href="https://lingsamuel.github.io/2016/12/22/Kotlin-Tutorial-Chap-1/"/>
    <id>https://lingsamuel.github.io/2016/12/22/Kotlin-Tutorial-Chap-1/</id>
    <published>2016-12-22T13:59:10.000Z</published>
    <updated>2017-01-03T17:04:14.570Z</updated>
    
    <content type="html"><![CDATA[<p>Introduction to basic Kotlin</p>
<a id="more"></a>
<h1 id="What’s-Kotlin"><a href="#What’s-Kotlin" class="headerlink" title="What’s Kotlin"></a>What’s Kotlin</h1><p>Kotlin 是 JetBrains 推出的基于 JVM 的静态类型编程语言。</p>
<p>一大强推的 feature 是对 Java 的 100% 兼容，并且有 toJs 工具，就像他们自己的简介一样</p>
<blockquote>
<p>Statically typed programming language for the JVM, Android and the browser.<br>100% interoperable with Java™</p>
</blockquote>
<h1 id="Why-Kotlin"><a href="#Why-Kotlin" class="headerlink" title="Why Kotlin"></a>Why Kotlin</h1><p>给出我自己的理由。</p>
<ol>
<li>表达力强。</li>
<li>100% 兼容 Java。</li>
<li>有函数式特性。</li>
<li>避免了一些 Java 的坑。</li>
<li>Null-Safety</li>
</ol>
<p>第一点是非常明显的。作为入门语言是 Java 的人，自我了解了更多的语言（尤其是函数式语言）后，愈发难以忍受 Java 的复杂。<br>Java 是一门非常非常咸的语言，初学者很难掌握 OOP 的精髓（当然也是我个人理解的），这会导致复杂度的急剧上升，出现那种“为了 OO 而 OO”的代码，是非常难看并且难以维护的。<br>而 Kotlin 有很多的糖，表达力也是足够的，能够使代码更加简洁、清晰，易于维护。</p>
<p>第二点是最重要的一点，也是使用 Kotlin 的重要理由之一。它能完美兼容 Java，这意味着你可以慢慢迁移到 Kotlin，不顺手了可以立马切回 Java 而不用担心任何问题。并且使得 Kotlin 天生就拥有数量庞大的库。</p>
<p>第三点纯粹是写得爽。</p>
<p>第四点参考 <a href="https://kotlinlang.org/docs/reference/comparison-to-java.html" target="_blank" rel="external">Comparison to Java</a></p>
<p>第五点似乎没那么紧要，但 Null-Safety 强制作者考虑 null 情形，大部分情况下是有利的，而且因为第一点，这并不会使得你的代码长很多。</p>
<p>额外加分项：</p>
<ol>
<li><p>Kotlin 不像 Haskell 那样过分“学术”，而是和工程紧密结合的。</p>
</li>
<li><p>Kotlin 的作者们是世界上最强的一帮科学家和工程师，我相信他们的经验 XD。</p>
</li>
<li><p>我是 JetBrains 粉丝。</p>
</li>
</ol>
<h1 id="Quickstart-Basic-but-Best-Practice"><a href="#Quickstart-Basic-but-Best-Practice" class="headerlink" title="Quickstart (Basic but Best Practice)"></a>Quickstart (Basic but Best Practice)</h1><hr>
<h2 id="Semicolon-Free"><a href="#Semicolon-Free" class="headerlink" title="Semicolon Free"></a>Semicolon Free</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p>不需要严格遵循文件夹<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> kt.intro.wherever</div><div class="line"></div><div class="line"><span class="keyword">import</span> sarasa.doc</div></pre></td></tr></table></figure></p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Unit 或可推导的表达式函数的返回值可省略，其余时候不能省略。<br>如果函数返回值是 Unit，尽可能让它纯，并且尽可能使用表达式函数。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">func</span><span class="params">(a: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</div></pre></td></tr></table></figure></p>
<h3 id="Default-Parameters"><a href="#Default-Parameters" class="headerlink" title="Default Parameters"></a>Default Parameters</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Int</span> = <span class="number">0</span>, b: <span class="type">String</span> = <span class="string">"example"</span>)</span></span> &#123; &#125;</div><div class="line"></div><div class="line">foo(b = <span class="string">"wow"</span>)</div></pre></td></tr></table></figure>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><p>类型后置<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v: <span class="built_in">Int</span> = <span class="number">1</span></div><div class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span> = <span class="number">1</span> <span class="comment">// const value</span></div></pre></td></tr></table></figure></p>
<h2 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// comment</span></div><div class="line"><span class="comment">/* block </span></div><div class="line">	comment */</div></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">""" raw </span></div><div class="line">string """</div><div class="line"></div><div class="line"><span class="string">" string "</span></div><div class="line"></div><div class="line"><span class="string">" string <span class="subst">$&#123;arr[index]&#125;</span> "</span></div><div class="line"></div><div class="line"><span class="string">" string <span class="subst">$simpleIdentifier</span> "</span></div></pre></td></tr></table></figure>
<h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><h3 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h3><p><code>?</code>作尾缀<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Non-null"><a href="#Non-null" class="headerlink" title="Non-null"></a>Non-null</h3><p><code>!!</code>作尾缀<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">(any: <span class="type">Any</span>)</span></span>: String!! &#123;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Null-Check"><a href="#Null-Check" class="headerlink" title="Null Check"></a>Null Check</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x is nullable</span></div><div class="line">y = x * x <span class="comment">// yields an error because x can be null</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">if</span>(x != <span class="literal">null</span>) x * x <span class="keyword">else</span> <span class="literal">null</span> <span class="comment">// safety</span></div></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x is nullable</span></div><div class="line"><span class="keyword">if</span>(x == <span class="literal">null</span>) <span class="keyword">return</span></div><div class="line">y = x * x <span class="comment">//safety</span></div></pre></td></tr></table></figure>
<p>If not null and else<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(nullableArray?.length ?: <span class="string">"empty"</span>)</div></pre></td></tr></table></figure></p>
<p>If null<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> something = nullableVar ?: <span class="keyword">throw</span> Exception()</div></pre></td></tr></table></figure></p>
<p>If not null<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nullable?.let&#123; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Safe-Cast"><a href="#Safe-Cast" class="headerlink" title="Safe Cast"></a>Safe Cast</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> maybeInt: <span class="built_in">Int</span>? = str <span class="keyword">as</span>? <span class="built_in">Int</span></div></pre></td></tr></table></figure>
<h2 id="Type-Check"><a href="#Type-Check" class="headerlink" title="Type Check"></a>Type Check</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(x <span class="keyword">is</span> <span class="built_in">Int</span>)&#123; &#125;</div></pre></td></tr></table></figure>
<h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">when</span> (x)&#123;</div><div class="line">		<span class="number">10</span> -&gt; print(<span class="string">"10"</span>)</div><div class="line">		<span class="string">"Sarasa"</span> -&gt; print(<span class="string">"Sarasa"</span>)</div><div class="line">		<span class="keyword">is</span> <span class="built_in">Long</span> -&gt; print(<span class="string">"Long"</span>)</div><div class="line">		!<span class="keyword">is</span> String -&gt; print(<span class="string">"Not String"</span>)</div><div class="line">		<span class="keyword">else</span> -&gt; print(<span class="string">"unknown"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Collections-loop"><a href="#Collections-loop" class="headerlink" title="Collections loop"></a>Collections loop</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(something <span class="keyword">in</span> collections)&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(something <span class="keyword">in</span> collections)&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>((k, v) <span class="keyword">in</span> map)&#123; &#125;</div></pre></td></tr></table></figure>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(x <span class="keyword">in</span> <span class="number">1.</span>.y)&#123; &#125; </div><div class="line"></div><div class="line"><span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>)&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(x !<span class="keyword">in</span> <span class="number">1.</span>.y)&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span>)&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>)&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span> step <span class="number">2</span>)&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>)&#123; &#125; <span class="comment">//10 is excluded</span></div></pre></td></tr></table></figure>
<h2 id="Extension-Functions"><a href="#Extension-Functions" class="headerlink" title="Extension Functions"></a>Extension Functions</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">toLowerCase</span><span class="params">()</span></span> &#123; &#125;</div><div class="line"></div><div class="line"><span class="string">"UPPER CASE"</span>.toLowerCase()</div></pre></td></tr></table></figure>
<h2 id="it"><a href="#it" class="headerlink" title="it"></a>it</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.filter &#123; x -&gt; x &gt; <span class="number">0</span> &#125;</div><div class="line"><span class="comment">// equals</span></div><div class="line">list.filter &#123; it &gt; <span class="number">0</span> &#125;</div></pre></td></tr></table></figure>
<h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Something &#123; &#125;</div></pre></td></tr></table></figure>
<h2 id="With"><a href="#With" class="headerlink" title="With"></a>With</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">f1</span><span class="params">()</span></span></div><div class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">f2</span><span class="params">()</span></span></div><div class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">f3</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> foo = Foo()</div><div class="line">with(foo) &#123;</div><div class="line">	f1()</div><div class="line">	<span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>)&#123;</div><div class="line">		f2()</div><div class="line">	&#125;</div><div class="line">	f3()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Generics-Basic"><a href="#Generics-Basic" class="headerlink" title="Generics (Basic)"></a>Generics (Basic)</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxedType</span>&lt;<span class="type">T</span>&gt;</span>(t: T) &#123; </div><div class="line">	<span class="keyword">var</span> Value = t</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">val</span> intBox = Box(<span class="number">1</span>) <span class="comment">// type inference</span></div><div class="line"><span class="keyword">val</span> intBox2: Box&lt;<span class="built_in">Int</span>&gt; = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<h3 id="Function-1"><a href="#Function-1" class="headerlink" title="Function"></a>Function</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">foo</span><span class="params">(t: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123; &#125;</div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">toString</span><span class="params">()</span></span>: String &#123; &#125; <span class="comment">// extension function</span></div></pre></td></tr></table></figure>
<h3 id="Bounded-Constraints"><a href="#Bounded-Constraints" class="headerlink" title="Bounded Constraints"></a>Bounded Constraints</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123; &#125;</div></pre></td></tr></table></figure>
<h2 id="Data-Transform-Object"><a href="#Data-Transform-Object" class="headerlink" title="Data Transform Object"></a>Data Transform Object</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">DTO</span></span>(<span class="keyword">val</span> name: String)</div></pre></td></tr></table></figure>
<p>它会默认具有：</p>
<ol>
<li>getter/setter</li>
<li>equals()</li>
<li>hashCode()</li>
<li>toString()</li>
<li>copy()</li>
<li>componentN()</li>
</ol>
<p>componentN() 将在未来提及。</p>
<h1 id="Code-Style"><a href="#Code-Style" class="headerlink" title="Code Style"></a>Code Style</h1><ol>
<li>驼峰命名 <code>camelCase</code></li>
<li>类型大写开头 <code>Type</code></li>
<li>四个空格</li>
<li>public function 需要文档</li>
<li>类型前冒号后有空格 <code>name: Type</code></li>
<li>省略 Unit 如果它是返回值</li>
<li>lambda 和花括号间有空格，箭头附近有空格 <code>list.filter { x -&gt; x &gt; 10 }</code></li>
</ol>
<blockquote>
<p>End —— Kisaragi Sarasa</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Introduction to basic Kotlin&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="https://lingsamuel.github.io/tags/Kotlin/"/>
    
      <category term="Tutorial" scheme="https://lingsamuel.github.io/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Your Type Notes Chap.1</title>
    <link href="https://lingsamuel.github.io/2016/12/20/Your-Type-Notes-Chap-1/"/>
    <id>https://lingsamuel.github.io/2016/12/20/Your-Type-Notes-Chap-1/</id>
    <published>2016-12-20T11:37:21.000Z</published>
    <updated>2016-12-21T04:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>你的类型， 1: 基础推理</p>
<a id="more"></a>
<h1 id="你的类型"><a href="#你的类型" class="headerlink" title="你的类型"></a>你的类型</h1><p>原址: <a href="https://zhuanlan.zhihu.com/p/24195357" target="_blank" rel="external">你的类型, 1: 基础推理</a></p>
<blockquote>
<p>作者：Belleve<br>链接：<a href="https://zhuanlan.zhihu.com/p/24195357" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24195357</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p>笔记、代码注释，不保证正确性，也不解释原理（也许有一天我会想回来解释）。</p>
<blockquote>
<p>继续上一节：上一节中，我们实现了单态类型的合一，而多态类型，此处即指加有的类型，在实现中，我们把这些变量用一个 Set 存储：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToNumberingScheme</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> baseChar = (<span class="string">"a"</span>).charCodeAt(<span class="number">0</span>);</div><div class="line">	<span class="keyword">let</span> letters = <span class="string">""</span>;</div><div class="line"></div><div class="line">	<span class="keyword">do</span> &#123;</div><div class="line">		number -= <span class="number">1</span>;</div><div class="line">		letters = <span class="built_in">String</span>.fromCharCode(baseChar + (number % <span class="number">26</span>)) + letters;</div><div class="line">		number = (number / <span class="number">26</span>) &gt;&gt; <span class="number">0</span>;</div><div class="line">	&#125; <span class="keyword">while</span> (number &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> letters;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polymorphic</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(quantifier, base) &#123;</div><div class="line">		<span class="comment">// Rename quantified slots</span></div><div class="line">		<span class="keyword">let</span> N = <span class="number">1</span>;</div><div class="line">		<span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">		<span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> quantifier) &#123;</div><div class="line">			<span class="keyword">let</span> param = slot(convertToNumberingScheme(N));</div><div class="line">			m.set(key, param);</div><div class="line">			s.add(param);</div><div class="line">			N++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.quantifier = s;</div><div class="line">		<span class="keyword">this</span>.base = base.applySub(m);</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">let</span> buf = <span class="string">"forall"</span>.red.bold;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.quantifier) &#123;</div><div class="line">			buf += <span class="string">" "</span> + item.inspect();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> buf + <span class="string">". "</span> + <span class="keyword">this</span>.base.inspect();</div><div class="line">	&#125;</div><div class="line">	instance(gen) &#123;</div><div class="line">		<span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="keyword">this</span>.quantifier) &#123;</div><div class="line">			m.set(key, gen());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.base.applySub(m);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在此处我们定义一个 instance 方法，它将多态类型的量化部分进行替换，生成一个单态的类型。</p>
<p>在前一节的 unify 中，我们还需要保证：当变量 a 合一到类型 b 的时候，b 中不能包含 a。我们用一个 freeFrom 方法实现：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A monomorphic type</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	getFreeSlots(m, a) &#123;&#125; <span class="comment">// Put free type variables, from mapping m, to set a</span></div><div class="line">	freeFrom(s) &#123;&#125; <span class="comment">// type t is free freom slot s</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Slots for free variables</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slot</span> <span class="keyword">extends</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	getFreeSlots(m, a) &#123;</div><div class="line">		<span class="keyword">if</span> (!m.has(<span class="keyword">this</span>) &amp;&amp; !a.has(<span class="keyword">this</span>)) a.add(<span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">	freeFrom(s) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span> !== s;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Primitive types</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span> <span class="keyword">extends</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	freeFrom(s) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Composite types, like [(-&gt;) a b] or [List a]</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	getFreeSlots(m, a) &#123;</div><div class="line">		<span class="keyword">this</span>.ctor.getFreeSlots(m, a);</div><div class="line">		<span class="keyword">this</span>.argument.getFreeSlots(m, a);</div><div class="line">	&#125;</div><div class="line">	freeFrom(s) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.ctor.freeFrom(s) &amp;&amp; <span class="keyword">this</span>.argument.freeFrom(s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">在合一的时候，检查是否成环：如果成环，表示无法合一（因为我们不打算实现递归类型）</div><div class="line"></div><div class="line"><span class="comment">// Unify two monomorphic types, p and q with slot mapping m.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unify</span>(<span class="params">m, s, t</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (s <span class="keyword">instanceof</span> Slot &amp;&amp; t <span class="keyword">instanceof</span> Slot &amp;&amp; s.applySub(m).equalTo(t.applySub(m))) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> Primitive &amp;&amp; t <span class="keyword">instanceof</span> Primitive &amp;&amp; s.name === t.name &amp;&amp; s.kind === t.kind) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> Composite &amp;&amp; t <span class="keyword">instanceof</span> Composite) &#123;</div><div class="line">		<span class="keyword">return</span> unify(m, s.ctor, t.ctor) &amp;&amp; unify(m, s.argument, t.argument);</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> Slot) &#123;</div><div class="line">		<span class="keyword">let</span> t1 = t.applySub(m);</div><div class="line">		<span class="keyword">if</span> (t1.freeFrom(s)) &#123;</div><div class="line">			m.set(s, t1);</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Slot) &#123;</div><div class="line">		<span class="keyword">let</span> s1 = s.applySub(m);</div><div class="line">		<span class="keyword">if</span> (s1.freeFrom(t)) &#123;</div><div class="line">			m.set(t, s1);</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>有了这些准备我们就可以去写类型推理了。在此处，推理规则如下：</p>
<p>对于全局的函数定义 function f x = body，我们可以先在一个次级作用域中，将 f 的类型设置为 ，x 的类型设置为，然后推导 body 的类型。如果可以成功推导，就提取处的自由变量，然后在 f 所在的作用域，将之定义。<br>对于嵌套函数定义，因为它可能会依赖外面的变量，而且这些「外面」变量的类型很可能也含有自由变量，典型例子是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function map f = let</div><div class="line">    function g a = if (empty? a)</div><div class="line">        newlist 0</div><div class="line">        cons (f (car a)) (map f (cdr a))</div><div class="line">    in g</div></pre></td></tr></table></figure></p>
<p>里面的 g，它依赖外部的 f，而 f 的类型则包含了自由变量。所以对于这些嵌套，它们需要按照相同的方式推理其类型，但是不能设置为多态。这个就是 Hindley-Milner 类型系统中最著名的 Let 多态限制。Lambda 将实现为一个 let。<br>对于函数调用 f x，我们首先推理 f 和 x 的类型 tf 与 tx，接着检查两组合一性：tf 是否和 s → t 合一 以及 tx 是否和 s 合一。如果都成立，我们就将表达式 f x 的类型推理为 t。<br>对于变量 x，返回其类型。如果它是多态的，那么就原位实例化之。<br>首先定义一个环境，它用来表示作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Environment</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(parent) &#123;</div><div class="line">		<span class="keyword">this</span>.parent = parent;</div><div class="line">		<span class="keyword">this</span>.variables = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">		<span class="keyword">this</span>.typeslots = parent ? parent.typeslots : <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">	&#125;</div><div class="line">	lookup(name) &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.variables.has(name)) <span class="keyword">return</span> <span class="keyword">this</span>.variables.get(name);</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.parent) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>.parent.lookup(name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>「环境」中，我们有一个程序变量表和一个类型变量表，后者是全局的，前者每一层 Environment 分别定义。</p>
<p>对变量表达式而言，实现很简单：查找变量表，返回其类型；如果是多态的，实例化之</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">	inspect() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Id</span> <span class="keyword">extends</span> <span class="title">Form</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	inference(env) &#123;</div><div class="line">		<span class="keyword">const</span> r = env.lookup(<span class="keyword">this</span>.name);</div><div class="line">		<span class="keyword">if</span> (!r) <span class="keyword">throw</span> <span class="keyword">new</span> VariableNotFoundError(<span class="keyword">this</span>.name);</div><div class="line">		<span class="keyword">if</span> (r <span class="keyword">instanceof</span> type.Polymorphic) &#123;</div><div class="line">			<span class="keyword">return</span> r.instance(newtype);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> r;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>对函数调用而言，进行两次合一</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apply</span> <span class="keyword">extends</span> <span class="title">Form</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(p, q) &#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.fn = p;</div><div class="line">		<span class="keyword">this</span>.argument = q;</div><div class="line">	&#125;</div><div class="line">	inference(env) &#123;</div><div class="line">		<span class="keyword">const</span> tfn = <span class="keyword">this</span>.fn.inference(env).applySub(env.typeslots);</div><div class="line">		<span class="keyword">const</span> targ = <span class="keyword">this</span>.argument.inference(env).applySub(env.typeslots);</div><div class="line"></div><div class="line">		<span class="keyword">const</span> s = newtype();</div><div class="line">		<span class="keyword">const</span> t = newtype();</div><div class="line">		<span class="keyword">const</span> psuidoArrow = type.arrow(s, t);</div><div class="line">		<span class="keyword">if</span> (!type.unify(env.typeslots, psuidoArrow, tfn)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Type of <span class="subst">$&#123;<span class="keyword">this</span>.fn.inspect()&#125;</span> is not a function : <span class="subst">$&#123;tfn.applySub(env.typeslots).inspect()&#125;</span>`</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">const</span> targ1 = s.applySub(env.typeslots);</div><div class="line">		<span class="keyword">if</span> (!type.unify(env.typeslots, targ1, targ)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TypeIncompatibleError(</div><div class="line">				<span class="keyword">this</span>.argument,</div><div class="line">				targ1.applySub(env.typeslots),</div><div class="line">				targ.applySub(env.typeslots),</div><div class="line">				<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">const</span> tresult = t.applySub(env.typeslots);</div><div class="line">		<span class="keyword">return</span> tresult;</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">if</span> (!(<span class="keyword">this</span>.argument <span class="keyword">instanceof</span> Id)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.fn.inspect() + <span class="string">" ("</span> + <span class="keyword">this</span>.argument.inspect() + <span class="string">")"</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.fn.inspect() + <span class="string">" "</span> + <span class="keyword">this</span>.argument.inspect();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>对函数定义而言，需要一个额外的 local 属性，表示其是否是嵌套的；如果是，则返回单态的结果</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FDef</span> <span class="keyword">extends</span> <span class="title">Form</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name, p, q, local) &#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.parameter = p;</div><div class="line">		<span class="keyword">this</span>.body = q;</div><div class="line">		<span class="keyword">this</span>.local = !!local;</div><div class="line">	&#125;</div><div class="line">	inference(env) &#123;</div><div class="line">		<span class="keyword">const</span> e = <span class="keyword">new</span> Environment(env);</div><div class="line">		<span class="keyword">const</span> alpha = newtype(<span class="string">"A"</span>);</div><div class="line">		<span class="keyword">const</span> beta = newtype(<span class="string">"B"</span>);</div><div class="line">		<span class="keyword">const</span> fntype0 = type.arrow(alpha, beta);</div><div class="line">		e.variables.set(<span class="keyword">this</span>.parameter.name, alpha);</div><div class="line">		e.variables.set(<span class="keyword">this</span>.name, type.arrow(alpha, beta));</div><div class="line">		e.typeslots.set(beta, <span class="keyword">this</span>.body.inference(e));</div><div class="line">		<span class="keyword">const</span> fnType = fntype0.applySub(e.typeslots);</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.local) &#123;</div><div class="line">			env.variables.set(<span class="keyword">this</span>.name, fnType);</div><div class="line">			<span class="keyword">return</span> fnType;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">const</span> fsm = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">			fnType.getFreeSlots(e.typeslots, fsm);</div><div class="line">			<span class="keyword">const</span> polytype = <span class="keyword">new</span> type.Polymorphic(fsm, fnType);</div><div class="line">			env.variables.set(<span class="keyword">this</span>.name, polytype);</div><div class="line">			<span class="keyword">return</span> polytype.instance(newtype);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"function "</span> + <span class="keyword">this</span>.name + <span class="string">" "</span> + <span class="keyword">this</span>.parameter.inspect() + <span class="string">" = "</span> + <span class="keyword">this</span>.body.inspect();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>最后一个是简单的「赋值」</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assign</span> <span class="keyword">extends</span> <span class="title">Form</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name, p) &#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.argument = p;</div><div class="line">	&#125;</div><div class="line">	inference(env) &#123;</div><div class="line">		<span class="keyword">const</span> t = <span class="keyword">this</span>.argument.inference(env);</div><div class="line">		env.variables.set(<span class="keyword">this</span>.name, t);</div><div class="line">		<span class="keyword">return</span> t;</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"set "</span> + <span class="keyword">this</span>.name + <span class="string">" = "</span> + <span class="keyword">this</span>.argument.inspect();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>到此为止，HM 推理的核心部分就构建完成了，下面是一些示例：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> env = <span class="keyword">new</span> Environment(<span class="literal">null</span>);</div><div class="line"><span class="comment">// This is a prelude</span></div><div class="line"><span class="comment">// call : forall a b. (a -&gt; b) -&gt; a -&gt; b;</span></div><div class="line">env.variables.set(<span class="string">"call"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>), type.slot(<span class="string">"b"</span>)]),</div><div class="line">		type.arrow(type.arrow(type.slot(<span class="string">"a"</span>), type.slot(<span class="string">"b"</span>)), type.arrow(type.slot(<span class="string">"a"</span>), type.slot(<span class="string">"b"</span>)))</div><div class="line">	));</div><div class="line"><span class="comment">// seq : forall a b. a -&gt; b -&gt; b</span></div><div class="line">env.variables.set(<span class="string">"seq"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>), type.slot(<span class="string">"b"</span>)]),</div><div class="line">		type.arrow(type.slot(<span class="string">"a"</span>), type.arrow(type.slot(<span class="string">"b"</span>), type.slot(<span class="string">"b"</span>)))</div><div class="line">	));</div><div class="line"><span class="comment">// car : forall a. list a -&gt; a</span></div><div class="line">env.variables.set(<span class="string">"car"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>)]),</div><div class="line">		type.arrow(type.cmpt(type.prim(<span class="string">"list"</span>), type.slot(<span class="string">"a"</span>)), type.slot(<span class="string">"a"</span>))</div><div class="line">	));</div><div class="line"><span class="comment">// cdr : forall a. list a -&gt; list a</span></div><div class="line">env.variables.set(<span class="string">"cdr"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>)]),</div><div class="line">		type.arrow(type.cmpt(type.prim(<span class="string">"list"</span>), type.slot(<span class="string">"a"</span>)), type.cmpt(type.prim(<span class="string">"list"</span>), type.slot(<span class="string">"a"</span>)))</div><div class="line">	));</div><div class="line"><span class="comment">// cons : forall a. a -&gt; list a -&gt; list a</span></div><div class="line">env.variables.set(<span class="string">"cons"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>)]),</div><div class="line">		type.arrow(</div><div class="line">			type.slot(<span class="string">"a"</span>),</div><div class="line">			type.arrow(</div><div class="line">				type.cmpt(type.prim(<span class="string">"list"</span>), type.slot(<span class="string">"a"</span>)),</div><div class="line">				type.cmpt(type.prim(<span class="string">"list"</span>), type.slot(<span class="string">"a"</span>))))</div><div class="line">	));</div><div class="line"><span class="comment">// newlist : forall a. unit -&gt; list a</span></div><div class="line">env.variables.set(<span class="string">"newlist"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>)]),</div><div class="line">		type.arrow(</div><div class="line">			type.prim(<span class="string">"unit"</span>),</div><div class="line">			type.cmpt(type.prim(<span class="string">"list"</span>), type.slot(<span class="string">"a"</span>)))</div><div class="line">	));</div><div class="line"><span class="comment">// empty? : forall a. list a -&gt; bool</span></div><div class="line">env.variables.set(<span class="string">"empty?"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>)]),</div><div class="line">		type.arrow(type.cmpt(type.prim(<span class="string">"list"</span>), type.slot(<span class="string">"a"</span>)), type.prim(<span class="string">"bool"</span>))</div><div class="line">	));</div><div class="line"><span class="comment">// 0 and 1</span></div><div class="line">env.variables.set(<span class="string">"0"</span>, type.prim(<span class="string">"int"</span>));</div><div class="line">env.variables.set(<span class="string">"1"</span>, type.prim(<span class="string">"int"</span>));</div><div class="line">env.variables.set(<span class="string">"nothing"</span>, type.prim(<span class="string">"unit"</span>));</div><div class="line"><span class="comment">// +</span></div><div class="line">env.variables.set(<span class="string">"+"</span>,</div><div class="line">	type.arrow(type.prim(<span class="string">"int"</span>),</div><div class="line">		type.arrow(type.prim(<span class="string">"int"</span>), type.prim(<span class="string">"int"</span>))));</div><div class="line"><span class="comment">// if : forall a. bool -&gt; thunk a -&gt; thunk a -&gt; a</span></div><div class="line">env.variables.set(<span class="string">"if"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>)]),</div><div class="line">		type.arrow(type.prim(<span class="string">"bool"</span>),</div><div class="line">			type.arrow(type.cmpt(type.prim(<span class="string">"thunk"</span>), type.slot(<span class="string">"a"</span>)),</div><div class="line">				type.arrow(type.cmpt(type.prim(<span class="string">"thunk"</span>), type.slot(<span class="string">"a"</span>)), type.slot(<span class="string">"a"</span>))))));</div><div class="line"><span class="comment">// hold : forall a. a -&gt; thunk a</span></div><div class="line">env.variables.set(<span class="string">"hold"</span>,</div><div class="line">	<span class="keyword">new</span> type.Polymorphic(</div><div class="line">		<span class="keyword">new</span> <span class="built_in">Set</span>([type.slot(<span class="string">"a"</span>)]),</div><div class="line">		type.arrow(type.slot(<span class="string">"a"</span>),</div><div class="line">			type.cmpt(type.prim(<span class="string">"thunk"</span>), type.slot(<span class="string">"a"</span>)))));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (a[<span class="number">0</span>] === <span class="string">"function"</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> FDef(a[<span class="number">1</span>], translate(a[<span class="number">2</span>]), translate(a[<span class="number">3</span>]));</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] === <span class="string">"let"</span> &amp;&amp; a.length === <span class="number">3</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Assign(a[<span class="number">1</span>], translate(a[<span class="number">2</span>]));</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] === <span class="string">"letf"</span> &amp;&amp; a.length === <span class="number">4</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> FDef(a[<span class="number">1</span>], translate(a[<span class="number">2</span>]), translate(a[<span class="number">3</span>]), <span class="literal">true</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] === <span class="string">"lambda"</span>) &#123;</div><div class="line">			<span class="keyword">const</span> t = newvar();</div><div class="line">			<span class="keyword">return</span> translate([<span class="string">"seq"</span>, [<span class="string">"letf"</span>, t, a[<span class="number">1</span>], a[<span class="number">2</span>]], t]);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] === <span class="string">"begin"</span>) &#123;</div><div class="line">			<span class="keyword">return</span> translate(a.slice(<span class="number">1</span>).reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> [<span class="string">"seq"</span>, x, y]));</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.length === <span class="number">2</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Apply(translate(a[<span class="number">0</span>]), translate(a[<span class="number">1</span>]));</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Apply(translate(a.slice(<span class="number">0</span>, a.length - <span class="number">1</span>)), translate(a[a.length - <span class="number">1</span>]));</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Id(a);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> f_id = translate(</div><div class="line">	[<span class="string">"function"</span>, <span class="string">"crz"</span>, <span class="string">"x"</span>, [<span class="string">"seq"</span>,</div><div class="line">		[<span class="string">"letf"</span>, <span class="string">"crz1"</span>, <span class="string">"y"</span>, [<span class="string">"seq"</span>,</div><div class="line">			[<span class="string">"letf"</span>, <span class="string">"crz2"</span>, <span class="string">"z"</span>,</div><div class="line">				[<span class="string">"seq"</span>, <span class="string">"x"</span>, [<span class="string">"seq"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>]]],</div><div class="line">			<span class="string">"crz2"</span>]</div><div class="line">		],</div><div class="line">		<span class="string">"crz1"</span>]]);</div><div class="line"><span class="keyword">const</span> f_length = translate(</div><div class="line">	[<span class="string">"function"</span>, <span class="string">"length"</span>, <span class="string">"a"</span>,</div><div class="line">		[<span class="string">"if"</span>, [<span class="string">"empty?"</span>, <span class="string">"a"</span>],</div><div class="line">			[<span class="string">"hold"</span>, <span class="string">"0"</span>],</div><div class="line">			[<span class="string">"hold"</span>, [<span class="string">"+"</span>, <span class="string">"1"</span>, [<span class="string">"length"</span>, [<span class="string">"cdr"</span>, <span class="string">"a"</span>]]]]]]);</div><div class="line"><span class="keyword">const</span> f_sum = translate(</div><div class="line">	[<span class="string">"function"</span>, <span class="string">"sum"</span>, <span class="string">"a"</span>,</div><div class="line">		[<span class="string">"if"</span>, [<span class="string">"empty?"</span>, <span class="string">"a"</span>],</div><div class="line">			[<span class="string">"hold"</span>, <span class="string">"0"</span>],</div><div class="line">			[<span class="string">"hold"</span>, [<span class="string">"+"</span>, [<span class="string">"car"</span>, <span class="string">"a"</span>], [<span class="string">"sum"</span>, [<span class="string">"cdr"</span>, <span class="string">"a"</span>]]]]]]);</div><div class="line"><span class="keyword">const</span> f_map = translate(</div><div class="line">	[<span class="string">"function"</span>, <span class="string">"map"</span>, <span class="string">"f"</span>, [<span class="string">"begin"</span>,</div><div class="line">		[<span class="string">"lambda"</span>, <span class="string">"a"</span>, [<span class="string">"if"</span>, [<span class="string">"empty?"</span>, <span class="string">"a"</span>],</div><div class="line">			[<span class="string">"hold"</span>, [<span class="string">"newlist"</span>, <span class="string">"nothing"</span>]],</div><div class="line">			[<span class="string">"hold"</span>, [<span class="string">"cons"</span>,</div><div class="line">				[<span class="string">"f"</span>, [<span class="string">"car"</span>, <span class="string">"a"</span>]],</div><div class="line">				[<span class="string">"map"</span>, <span class="string">"f"</span>, [<span class="string">"cdr"</span>, <span class="string">"a"</span>]]]]]]]]);</div><div class="line"></div><div class="line"><span class="keyword">const</span> foo = translate(</div><div class="line">	[<span class="string">"function"</span>, <span class="string">"foo"</span>, <span class="string">"f"</span>,</div><div class="line">		[<span class="string">"f"</span>, <span class="string">"+"</span>, [<span class="string">"f"</span>, <span class="string">"0"</span>], [<span class="string">"f"</span>, <span class="string">"1"</span>]]]);</div><div class="line"></div><div class="line">f_id.inference(env);</div><div class="line">f_length.inference(env);</div><div class="line">f_sum.inference(env);</div><div class="line">f_map.inference(env);</div><div class="line"><span class="comment">// foo.inference(env); // Should be an error</span></div><div class="line"><span class="built_in">console</span>.log(env.variables);</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果是：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Map &#123;</div><div class="line">  'call' =&gt; forall 'a 'b. ('a -&gt; 'b) -&gt; 'a -&gt; 'b,</div><div class="line">  'seq' =&gt; forall 'a 'b. 'a -&gt; 'b -&gt; 'b,</div><div class="line">  'car' =&gt; forall 'a. (list 'a) -&gt; 'a,</div><div class="line">  'cdr' =&gt; forall 'a. (list 'a) -&gt; list 'a,</div><div class="line">  'cons' =&gt; forall 'a. 'a -&gt; (list 'a) -&gt; list 'a,</div><div class="line">  'newlist' =&gt; forall 'a. unit -&gt; list 'a,</div><div class="line">  'empty?' =&gt; forall 'a. (list 'a) -&gt; bool,</div><div class="line">  '0' =&gt; int,</div><div class="line">  '1' =&gt; int,</div><div class="line">  'nothing' =&gt; unit,</div><div class="line">  '+' =&gt; int -&gt; int -&gt; int,</div><div class="line">  'if' =&gt; forall 'a. bool -&gt; (thunk 'a) -&gt; (thunk 'a) -&gt; 'a,</div><div class="line">  'hold' =&gt; forall 'a. 'a -&gt; thunk 'a,</div><div class="line">  'crz' =&gt; forall 'a 'b 'c. 'a -&gt; 'b -&gt; 'c -&gt; 'c,</div><div class="line">  'length' =&gt; forall 'a. (list 'a) -&gt; int,</div><div class="line">  'sum' =&gt; forall. (list int) -&gt; int,</div><div class="line">  'map' =&gt; forall 'a 'b. ('a -&gt; 'b) -&gt; (list 'a) -&gt; list 'b &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在之后的章节里我们将会尝试把类型推理改成 Monadic 的，并希望借此实现加法多态的推理；此外也会实现对于 AST 的 tagging。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的类型， 1: 基础推理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Note" scheme="https://lingsamuel.github.io/tags/Note/"/>
    
      <category term="Your Type" scheme="https://lingsamuel.github.io/tags/Your-Type/"/>
    
  </entry>
  
  <entry>
    <title>Your Type Notes Chap.0</title>
    <link href="https://lingsamuel.github.io/2016/12/20/Your-Type-Notes-Chap-0/"/>
    <id>https://lingsamuel.github.io/2016/12/20/Your-Type-Notes-Chap-0/</id>
    <published>2016-12-20T11:35:39.000Z</published>
    <updated>2016-12-20T16:05:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>你的类型， 0: 基本的合一</p>
<a id="more"></a>
<h1 id="你的类型"><a href="#你的类型" class="headerlink" title="你的类型"></a>你的类型</h1><p>原址: <a href="https://zhuanlan.zhihu.com/p/24181997" target="_blank" rel="external">你的类型, 0: 基本的合一</a></p>
<blockquote>
<p>作者：Belleve<br>链接：<a href="https://zhuanlan.zhihu.com/p/24181997" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24181997</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p>笔记、代码注释，不保证正确性，也不解释原理（也许有一天我会想回来解释）。</p>
<p>第零章真的特别简单。</p>
<hr>
<blockquote>
<p>简单粗暴的开始：用 JS 实现一个 ML 类的程序语言的类型推理系统。<br>在我们这里，所有的类型属于以下形式之一：</p>
<p>一个基础类型（Primitive）<br>一个自由变量（Slot）<br>一个复合类型（Composite），由一个构造器（ctor）和一个参数（argument）复合得到。对于 (-&gt;)、(*) 之类的二元构造器，使用 Curryize 将他变换为嵌套的 Composite。</p>
</blockquote>
<p>无需笔记。</p>
<hr>
<blockquote>
<p>所谓的合一，指的是：给出两个类型 A 和 B，找到一组变量替换，使得两者的自由变量经过替换之后可以得到一个相同的类型 C。考虑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A = ((α → β) × [γ]) → [β]， B = ((γ → δ) × [γ]) → ε</div></pre></td></tr></table></figure></p>
<p>这两个类型可以合一，对应的替换是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">〈α → α, β → β, γ → α, δ → β, ε → [β]〉</div></pre></td></tr></table></figure></p>
</blockquote>
<p>无需笔记。</p>
<hr>
<blockquote>
<p>实现合一的算法基本思路就是维护一个 slot 的映射。对于任意的类型 a 和 b，以及「当前状态」的映射 m：</p>
<p>如果 a 和 b 都是 slot 并且 m[a] == m[b]，那么 a b 可以合一，m 不变。<br>如果 a 和 b 都是 primitive 并且相同，那么 a b 可以合一，m 不变。<br>如果 a 是 slot，可以合一，并且需要 m[a] 设置为 b；反之亦然。<br>如果 a 和 b 都是 composite，检查两者的构造器和参数是否都能合一，m 会最多被设置两次。<br>对于其他一切情况，a 和 b 不能合一。</p>
</blockquote>
<hr>
<p>这份代码是做这件事情的：<br>制造几个类型，应用 <code>unify</code> 生成一个合一替换，对这些类型应用这个替换。<br><code>applySub</code> 函数是对某一类型应用这个合一替换的。<br>该合一替换在 js 中体现为一个 map。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A monomorphic type</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">	inspect() &#123;&#125; <span class="comment">// Pretty print type</span></div><div class="line">	applySub(m) &#123;&#125; <span class="comment">// Apply a substitution m</span></div><div class="line">	equalTo(t) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义了单态，没有什么特别的。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Slots for free variables</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slot</span> <span class="keyword">extends</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"#"</span> + <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">	applySub(m) &#123;</div><div class="line">		<span class="keyword">const</span> r = m.get(<span class="keyword">this</span>);</div><div class="line">		<span class="keyword">if</span> (!r || r === <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> r.applySub(m);</div><div class="line">	&#125;</div><div class="line">	equalTo(t) &#123;</div><div class="line">		<span class="keyword">return</span> t &amp;&amp; t <span class="keyword">instanceof</span> Slot &amp;&amp; <span class="keyword">this</span>.name === t.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="applySub"><a href="#applySub" class="headerlink" title="applySub"></a>applySub</h2><p><code>if (!r || r === this) return this;</code> 代表 a → a。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Primitive types</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span> <span class="keyword">extends</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name, kind) &#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">	applySub(m) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line">	equalTo(t) &#123;</div><div class="line">		<span class="keyword">return</span> t &amp;&amp; t <span class="keyword">instanceof</span> Primitive &amp;&amp; <span class="keyword">this</span>.name === t.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为是基本类型，所以直接原样返回就行了。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Composite types, like [(-&gt;) a b] or [List a]</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Monomorphic</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(ctor, argument) &#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.ctor = ctor;</div><div class="line">		<span class="keyword">this</span>.argument = argument;</div><div class="line">	&#125;</div><div class="line">	inspect() &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.argument <span class="keyword">instanceof</span> Composite) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.ctor.inspect() + <span class="string">" ("</span> + <span class="keyword">this</span>.argument.inspect() + <span class="string">")"</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.ctor.inspect() + <span class="string">" "</span> + <span class="keyword">this</span>.argument.inspect() + <span class="string">""</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	applySub(m) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Composite(<span class="keyword">this</span>.ctor.applySub(m), <span class="keyword">this</span>.argument.applySub(m));</div><div class="line">	&#125;</div><div class="line">	equalTo(t) &#123;</div><div class="line">		<span class="keyword">return</span> t &amp;&amp; t <span class="keyword">instanceof</span> Composite &amp;&amp; <span class="keyword">this</span>.ctor.equalTo(t.ctor) &amp;&amp; <span class="keyword">this</span>.argument.equalTo(t.argument);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="applySub-1"><a href="#applySub-1" class="headerlink" title="applySub"></a>applySub</h2><p>由于柯里化， <code>ctor</code> 也应当能被执行合一。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Unify two monomorphic types, p and q with slot mapping m.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unify</span>(<span class="params">m, s, t</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (s <span class="keyword">instanceof</span> Slot &amp;&amp; t <span class="keyword">instanceof</span> Slot &amp;&amp; s.applySub(m).equalTo(t.applySub(m))) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> Primitive &amp;&amp; t <span class="keyword">instanceof</span> Primitive &amp;&amp; s.name === t.name &amp;&amp; s.kind === t.kind) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> Composite &amp;&amp; t <span class="keyword">instanceof</span> Composite) &#123;</div><div class="line">		<span class="keyword">return</span> unify(m, s.ctor, t.ctor) &amp;&amp; unify(m, s.argument, t.argument);</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> Slot) &#123;</div><div class="line">		m.set(s, t);</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Slot) &#123;</div><div class="line">		m.set(t, s);</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就是对 1~5 的一一对应。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Slot symbol table</span></div><div class="line"><span class="keyword">let</span> st = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">slot</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (st[name])<span class="keyword">return</span> st[name];</div><div class="line">	<span class="keyword">const</span> t = <span class="keyword">new</span> Slot(name);</div><div class="line">	st[name] = t;</div><div class="line">	<span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Primitive symbol table</span></div><div class="line"><span class="keyword">let</span> pt = &#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pm</span>(<span class="params">name, kind</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (pt[name])<span class="keyword">return</span> pt[name];</div><div class="line">	<span class="keyword">const</span> t = <span class="keyword">new</span> Primitive(name, kind);</div><div class="line">	pt[name] = t;</div><div class="line">	<span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Composite types</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ct</span>(<span class="params">ctor, argument</span>) </span>&#123;</div><div class="line">	<span class="keyword">const</span> t = <span class="keyword">new</span> Composite(ctor, argument);</div><div class="line">	<span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrow</span>(<span class="params">p, q</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> ct(ct(pm(<span class="string">"[-&gt;]"</span>), p), q);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params">p, q</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> ct(ct(pm(<span class="string">"[*]"</span>), p), q);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="slot-pm"><a href="#slot-pm" class="headerlink" title="slot/pm"></a>slot/pm</h1><p>仅仅是往自由变量/基本类型里加东西并返回而已。</p>
<h1 id="ct"><a href="#ct" class="headerlink" title="ct"></a>ct</h1><p>仅仅是构造一个 <code>Composite</code> 而已。</p>
<h1 id="arrow-product"><a href="#arrow-product" class="headerlink" title="arrow/product"></a>arrow/product</h1><p>手动柯里化，最后的结果是 <code>[-&gt;] p q</code> / <code>[*] p q</code>。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> type1 =</div><div class="line">arrow(</div><div class="line">	product(</div><div class="line">  		arrow(slot(<span class="string">"a1"</span>), slot(<span class="string">"a2"</span>)),</div><div class="line">  		ct(pm(<span class="string">"list"</span>), slot(<span class="string">"a3"</span>))),</div><div class="line">  ct(pm(<span class="string">"list"</span>), slot(<span class="string">"a2"</span>)));</div></pre></td></tr></table></figure>
<p>它制造的类型是 <code>-&gt; (* (-&gt; a1 a2) (list a3)) (list a2)</code>。</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> type2 =</div><div class="line">arrow(</div><div class="line">	product(</div><div class="line">  		arrow(slot(<span class="string">"a3"</span>), slot(<span class="string">"a4"</span>)),</div><div class="line">  		ct(pm(<span class="string">"list"</span>), slot(<span class="string">"a3"</span>))),</div><div class="line">  slot(<span class="string">"a5"</span>));</div></pre></td></tr></table></figure>
<p>它制造的类型是 <code>-&gt; (* (-&gt; a3 a4) (list a3)) a5</code>。</p>
<hr>
<p>为直观理解，现手动分析 <code>unify</code> 这一过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-&gt; (* (-&gt; a1 a2) (list a3)) (list a2) unify -&gt; (* (-&gt; a3 a4) (list a3)) a5</div><div class="line">  -&gt; (* (-&gt; a1 a2) (list a3)) unify -&gt; (* (-&gt; a3 a4) (list a3))  以及 (list a2) unify a5</div><div class="line">    -&gt; unify -&gt; 以及 * (-&gt; a1 a2) (list a3) unify * (-&gt; a3 a4) (list a3)， list a2 与 a5 不能合一</div><div class="line">      m 不变， * (-&gt; a1 a2) unify * (-&gt; a3 a4) 以及 (list a3) unify (list a3)</div><div class="line">        * unify * 以及 (-&gt; a1 a2) unify (-&gt; a3 a4) 以及 list unify list 以及 a3 unify a3</div><div class="line">          （-&gt; a1) unify (-&gt; a3) 以及 a2 unify a4</div><div class="line">              -&gt; unify -&gt; 以及 a1 unify a3，a2 与 a4 不能合一</div><div class="line">                a1 与 a3 不能合一</div></pre></td></tr></table></figure>
<p>因此，合一替换为 a1 =&gt; a3, a2 =&gt; a4, a5 =&gt; list a2</p>
<p>考虑对 <code>type1</code> 进行合一替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apply -&gt; (* (-&gt; a1 a2) (list a3)) (list a2)</div><div class="line">  &#123;apply -&gt; (* (-&gt; a1 a2) (list a3))&#125; 以及 &#123;apply (list a2)&#125;</div><div class="line">    &#123;&#123;apply -&gt;&#125; 以及 &#123;apply * (-&gt; a1 a2) (list a3)&#125;&#125;， &#123;list， 以及 apply a2&#125;</div><div class="line">      &#123;-&gt;， &#123;&#123;apply * (-&gt; a1 a2)&#125; 以及 &#123;apply (list a3)&#125;&#125;&#125;， &#123;list， a2 =&gt; a4&#125;</div><div class="line">        &#123;-&gt; &#123;*， &#123;apply (-&gt; a1 a2)&#125;， &#123;list， 以及 apply a3&#125;&#125;&#125;， &#123;list, a4&#125;</div><div class="line">          &#123;-&gt; &#123;*， &#123;apply (-&gt; a1) 以及 apply a2&#125;， &#123;list， a3&#125;&#125;&#125;， &#123;list， a4&#125;</div><div class="line">            &#123;-&gt; &#123;*， &#123;apply -&gt; 以及 apply a1， a2&#125;， &#123;list， a3&#125;&#125;&#125;， &#123;list， a4&#125;</div><div class="line">              &#123;-&gt; &#123;* &#123;-&gt; a3 a2&#125; &#123;list a3&#125;&#125;&#125; &#123;list a4&#125;</div><div class="line">              即 (-&gt; (* (-&gt; a3 a2) (list a3))) (list a4)</div></pre></td></tr></table></figure></p>
<p><code>type2</code> 同理。</p>
<hr>
<blockquote>
<p>加括号好累哦。 —— Kisaragi Sarasa </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的类型， 0: 基本的合一&lt;/p&gt;
    
    </summary>
    
    
      <category term="Note" scheme="https://lingsamuel.github.io/tags/Note/"/>
    
      <category term="Your Type" scheme="https://lingsamuel.github.io/tags/Your-Type/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Lambda Calculus Chap.1</title>
    <link href="https://lingsamuel.github.io/2016/12/20/Introduction-to-Lambda-Calculus-Chap-1/"/>
    <id>https://lingsamuel.github.io/2016/12/20/Introduction-to-Lambda-Calculus-Chap-1/</id>
    <published>2016-12-20T10:21:02.000Z</published>
    <updated>2016-12-20T11:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lambda Calculus Notes (Introduction)</p>
<a id="more"></a>
<h1 id="规则-Rule"><a href="#规则-Rule" class="headerlink" title="规则 (Rule)"></a>规则 (Rule)</h1><p>规则定义了可被覆写的表达式 P，以及覆写结果 P’，<br>  写作 P -&gt; P’。</p>
<h1 id="归约-Reduction"><a href="#归约-Reduction" class="headerlink" title="归约 (Reduction)"></a>归约 (Reduction)</h1><p>表达式 E 是由一些规则组成的。</p>
<p>称 E[P] -&gt; E[P’] 为规约，<br>  若存在规则使 P -&gt; P’。</p>
<h1 id="标准型-Normal-Form"><a href="#标准型-Normal-Form" class="headerlink" title="标准型 (Normal Form)"></a>标准型 (Normal Form)</h1><p>称 E* 为 E 的标准型，<br>  若不存在规则能继续归约。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>考虑表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(2 * 4) * (3 + 4) -&gt;</div><div class="line">(8) * (3 + 4) -&gt;</div><div class="line">8 * (7) -&gt;</div><div class="line">56</div></pre></td></tr></table></figure>
<p>即为一种归约。</p>
<p>符号也能归约，只要定义适当的规则，事实上数字也是一种符号。</p>
<h1 id="组合子-Combinator"><a href="#组合子-Combinator" class="headerlink" title="组合子 (Combinator)"></a>组合子 (Combinator)</h1><p>若定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">append (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) (&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) -&gt;</div><div class="line">(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;)</div></pre></td></tr></table></figure>
<p>我们就称 append 这样的函数为组合子。</p>
<h1 id="Church-Rosser-Property"><a href="#Church-Rosser-Property" class="headerlink" title="Church-Rosser Property"></a>Church-Rosser Property</h1><p>称一个归约系统具有丘奇-罗素要素，<br>  若其标准型与子项归约顺序无关。</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h2><p>  考虑表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(2 * 4) * (3 + 4) -&gt;</div><div class="line">(2 * 4) * (7) -&gt;</div><div class="line">(8) * 7 -&gt;</div><div class="line">56</div></pre></td></tr></table></figure></p>
<h1 id="应用-Application"><a href="#应用-Application" class="headerlink" title="应用 (Application)"></a>应用 (Application)</h1><p>Application 是 lambda calculus 的基本运算之一。</p>
<p>表达式 <code>F . A</code> 或 <code>F A</code> 代表将 F 看作某种运算，并将之应用(apply)到 A 上。</p>
<p>这种运算有两种解读，<code>F A</code> 的运算过程，或是 <code>F A</code> 这个运算的结果。</p>
<p>它是无类型(Type-free)的，因为 <code>F F</code> 是合法的表达式。</p>
<h1 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 (Abstraction)"></a>抽象 (Abstraction)</h1><p>抽象是第二个 lambda calculus 的基本运算。<br>若 <code>M ≡ M[x]</code> 是一个依赖于 x 的表达式，那么 <code>x.M[x]</code> 等价于 <code>x -&gt; M[x]</code>。</p>
<p>那么 <code>(\x.x * x) 3</code> 等价于 <code>3 * 3 (= 9)</code>，</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lambda Calculus Notes (Introduction)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Lambda Calculus" scheme="https://lingsamuel.github.io/tags/Lambda-Calculus/"/>
    
      <category term="Note" scheme="https://lingsamuel.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Plan Of Next Two Years</title>
    <link href="https://lingsamuel.github.io/2016/12/19/Plan-Of-Next-Two-Years/"/>
    <id>https://lingsamuel.github.io/2016/12/19/Plan-Of-Next-Two-Years/</id>
    <published>2016-12-18T17:04:03.000Z</published>
    <updated>2016-12-20T11:36:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Be a salty fish, or be a carp who can become a loong?</p>
<a id="more"></a>
<h1 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h1><ol>
<li>C++ Primer</li>
<li>Elements of Programming</li>
<li>C Interfaces and Implement</li>
<li>Introduction of Algorithms</li>
<li>Learn You a Haskell for Great Good</li>
<li>Illustrated C-Sharp</li>
</ol>
<h1 id="Languages"><a href="#Languages" class="headerlink" title="Languages"></a>Languages</h1><ol>
<li>C++ (Craftman)</li>
<li>Java (Craftman)</li>
<li>Kotlin (Craftman)</li>
<li>Haskell (Resident)</li>
<li>C-Sharp (Worker)</li>
<li>JavaScript (Worker)</li>
<li>Scala (Sightseer)</li>
</ol>
<h1 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h1><ol>
<li>Shikaiia (Java/Kotlin as Backend, C# as Frontend)</li>
</ol>
<h1 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h1><ol>
<li>Code Wars</li>
</ol>
<h1 id="Articles"><a href="#Articles" class="headerlink" title="Articles"></a>Articles</h1><ol>
<li>Haskell in Dreamland</li>
<li>Creatures in Shikaiia</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Be a salty fish, or be a carp who can become a loong?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Plan" scheme="https://lingsamuel.github.io/tags/Plan/"/>
    
  </entry>
  
  <entry>
    <title>Gorgeous Dreamland</title>
    <link href="https://lingsamuel.github.io/2016/12/18/Gorgeous-Dreamland/"/>
    <id>https://lingsamuel.github.io/2016/12/18/Gorgeous-Dreamland/</id>
    <published>2016-12-17T16:42:30.000Z</published>
    <updated>2016-12-20T11:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些梦境，当然细节可能早已忘记。<br><a id="more"></a></p>
<h1 id="The-Incredible-Adventure"><a href="#The-Incredible-Adventure" class="headerlink" title="The Incredible Adventure"></a>The Incredible Adventure</h1><p>Date: 2016-12-17 15:00:00</p>
<h2 id="普通的实验"><a href="#普通的实验" class="headerlink" title="普通的实验"></a>普通的实验</h2><p>小剧场似乎比记忆中的大很多，也不像记忆中那样冷清。一些“知名的教授”在这里举行了三场实验。</p>
<p>我还是一如既往地不记事，错过了报名。</p>
<p>实验在一个从没有见过的小房间举行，似乎内容是关于 VR 对人类心理的影响。</p>
<p>第一场毕，大卫从实验场地出来，陆陆续续大家都走了出来，但似乎都有点没精神。</p>
<p>问了一遍又一遍，他也不肯告诉我实验的内容，也许是实验保密协议吧。</p>
<p>他躺在从没见过的草地上，不知道在想什么，也许是在想今天的六级考试吧。</p>
<h2 id="保密的实验"><a href="#保密的实验" class="headerlink" title="保密的实验"></a>保密的实验</h2><p>很快我就发现这个实验并不是那么严格地保密的。</p>
<p>在第二场开始时，我直接在门外瞥见了场内的设施，还有一些已经开始实验的学生。</p>
<p>设施有两种，都是圆柱形的，一种竖起来，一种放倒，似乎有一些手掌大的孔可以朝仪器里看。</p>
<p>有的学生在朝仪器里看，有些学生趴在桌子上。</p>
<p>“也许这就是那种新型的 VR 设备吧？”我这么想着，但似乎偷窥别人的实验也不是什么好事，就走开了。</p>
<p>我记得三楼是琴房和一些社团的样子，但这个没见过的房间的楼上是什么还没看过。</p>
<p>正准备往楼上走，我看到保洁阿姨推开了门两侧都有的什么东西并朝实验房内看去。</p>
<h2 id="伦理学家"><a href="#伦理学家" class="headerlink" title="伦理学家"></a>伦理学家</h2><p>出乎意料地，楼上非常小，并且除了几个靠墙边的大箱子以外什么也没有。</p>
<p>但是我马上知道我错了。保洁阿姨推开的东西就是这些箱子。</p>
<p>我很想直到她们在看什么，但她们看到我后马上就惊慌地不再朝内看了。</p>
<p>我又往楼上走去，发现箱子已经被推开了。</p>
<p>一扇门露了出来。</p>
<p>以我这个角度朝内看去，似乎能看到实验场地的一角。</p>
<p>躲到门边小心地听，隐约能听到一些低沉的声音在交流。隐约听到一个声音说，</p>
<p>“到你了。”</p>
<p>我猜测他们的实验是一场里有好几轮，研究人员是轮流进行的。</p>
<p>但是相反地，这个研究员没有进去实验，而是走了出来，我吓得想走，但来不及了。</p>
<p>可是他看到我并没有什么反应。</p>
<p>脑中突然闪过了什么东西，我蹦出一句，</p>
<p>“你是一个伦理学家？”</p>
<p>他回头看了我一言，露出了一丝神秘的笑。</p>
<p>To Be Continue…</p>
<h2 id="一些解释"><a href="#一些解释" class="headerlink" title="一些解释"></a>一些解释</h2><h3 id="大箱子"><a href="#大箱子" class="headerlink" title="大箱子"></a>大箱子</h3><p>文中提到的大箱子，是一种类似求是潮宣传用的部门箱子一样的东西。</p>
<p>并且似乎有一种魔力，在它们被保洁阿姨推开前，我完全没有发现它们的存在。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些梦境，当然细节可能早已忘记。&lt;br&gt;
    
    </summary>
    
    
      <category term="Dream" scheme="https://lingsamuel.github.io/tags/Dream/"/>
    
  </entry>
  
</feed>
